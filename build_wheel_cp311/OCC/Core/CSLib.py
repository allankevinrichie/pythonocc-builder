# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
CSLib module, see official documentation at
https://dev.opencascade.org/doc/occt-7.9.0/refman/html/package_cslib.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CSLib
else:
    import _CSLib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CSLib.delete_SwigPyIterator

    def value(self):
        return _CSLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CSLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CSLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CSLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CSLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CSLib.SwigPyIterator_copy(self)

    def next(self):
        return _CSLib.SwigPyIterator_next(self)

    def __next__(self):
        return _CSLib.SwigPyIterator___next__(self)

    def previous(self):
        return _CSLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CSLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CSLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CSLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CSLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CSLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CSLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CSLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CSLib:
_CSLib.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string

PYTHONOCC_DEBUG_EXCEPTIONS = _CSLib.PYTHONOCC_DEBUG_EXCEPTIONS

def get_readable_class_name(class_name):
    return _CSLib.get_readable_class_name(class_name)

def get_readable_method_name(method_name):
    return _CSLib.get_readable_method_name(method_name)

def get_exception_type(error):
    return _CSLib.get_exception_type(error)

def process_opencascade_exception(error, method_name, class_name):
    return _CSLib.process_opencascade_exception(error, method_name, class_name)

import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _CSLib.ios_base_erase_event
    imbue_event = _CSLib.ios_base_imbue_event
    copyfmt_event = _CSLib.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _CSLib.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _CSLib.ios_base_flags(self, *args)

    def setf(self, *args):
        return _CSLib.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _CSLib.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _CSLib.ios_base_precision(self, *args)

    def width(self, *args):
        return _CSLib.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _CSLib.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _CSLib.ios_base_imbue(self, __loc)

    def getloc(self):
        return _CSLib.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _CSLib.ios_base_xalloc()

    def iword(self, __ix):
        return _CSLib.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _CSLib.ios_base_pword(self, __ix)
    __swig_destroy__ = _CSLib.delete_ios_base

# Register ios_base in _CSLib:
_CSLib.ios_base_swigregister(ios_base)
cvar = _CSLib.cvar
ios_base.boolalpha = _CSLib.cvar.ios_base_boolalpha
ios_base.dec = _CSLib.cvar.ios_base_dec
ios_base.fixed = _CSLib.cvar.ios_base_fixed
ios_base.hex = _CSLib.cvar.ios_base_hex
ios_base.internal = _CSLib.cvar.ios_base_internal
ios_base.left = _CSLib.cvar.ios_base_left
ios_base.oct = _CSLib.cvar.ios_base_oct
ios_base.right = _CSLib.cvar.ios_base_right
ios_base.scientific = _CSLib.cvar.ios_base_scientific
ios_base.showbase = _CSLib.cvar.ios_base_showbase
ios_base.showpoint = _CSLib.cvar.ios_base_showpoint
ios_base.showpos = _CSLib.cvar.ios_base_showpos
ios_base.skipws = _CSLib.cvar.ios_base_skipws
ios_base.unitbuf = _CSLib.cvar.ios_base_unitbuf
ios_base.uppercase = _CSLib.cvar.ios_base_uppercase
ios_base.adjustfield = _CSLib.cvar.ios_base_adjustfield
ios_base.basefield = _CSLib.cvar.ios_base_basefield
ios_base.floatfield = _CSLib.cvar.ios_base_floatfield
ios_base.badbit = _CSLib.cvar.ios_base_badbit
ios_base.eofbit = _CSLib.cvar.ios_base_eofbit
ios_base.failbit = _CSLib.cvar.ios_base_failbit
ios_base.goodbit = _CSLib.cvar.ios_base_goodbit
ios_base.app = _CSLib.cvar.ios_base_app
ios_base.ate = _CSLib.cvar.ios_base_ate
ios_base.binary = _CSLib.cvar.ios_base_binary
ios_base.ios_base_in = _CSLib.cvar.ios_base_ios_base_in
ios_base.out = _CSLib.cvar.ios_base_out
ios_base.trunc = _CSLib.cvar.ios_base_trunc
ios_base.beg = _CSLib.cvar.ios_base_beg
ios_base.cur = _CSLib.cvar.ios_base_cur
ios_base.end = _CSLib.cvar.ios_base_end

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _CSLib.ios_rdstate(self)

    def clear(self, *args):
        return _CSLib.ios_clear(self, *args)

    def setstate(self, __state):
        return _CSLib.ios_setstate(self, __state)

    def good(self):
        return _CSLib.ios_good(self)

    def eof(self):
        return _CSLib.ios_eof(self)

    def fail(self):
        return _CSLib.ios_fail(self)

    def bad(self):
        return _CSLib.ios_bad(self)

    def exceptions(self, *args):
        return _CSLib.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _CSLib.ios_swiginit(self, _CSLib.new_ios(__sb))
    __swig_destroy__ = _CSLib.delete_ios

    def tie(self, *args):
        return _CSLib.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _CSLib.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _CSLib.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _CSLib.ios_fill(self, *args)

    def imbue(self, __loc):
        return _CSLib.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _CSLib.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _CSLib.ios_widen(self, __c)

# Register ios in _CSLib:
_CSLib.ios_swigregister(ios)
class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CSLib.ostream_swiginit(self, _CSLib.new_ostream(__sb))
    __swig_destroy__ = _CSLib.delete_ostream

    def __lshift__(self, *args):
        return _CSLib.ostream___lshift__(self, *args)

    def put(self, __c):
        return _CSLib.ostream_put(self, __c)

    def write(self, __s, __n):
        return _CSLib.ostream_write(self, __s, __n)

    def flush(self):
        return _CSLib.ostream_flush(self)

    def tellp(self):
        return _CSLib.ostream_tellp(self)

    def seekp(self, *args):
        return _CSLib.ostream_seekp(self, *args)

# Register ostream in _CSLib:
_CSLib.ostream_swigregister(ostream)
class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CSLib.istream_swiginit(self, _CSLib.new_istream(__sb))
    __swig_destroy__ = _CSLib.delete_istream

    def __rshift__(self, *args):
        return _CSLib.istream___rshift__(self, *args)

    def gcount(self):
        return _CSLib.istream_gcount(self)

    def get(self, *args):
        return _CSLib.istream_get(self, *args)

    def getline(self, *args):
        return _CSLib.istream_getline(self, *args)

    def ignore(self, *args):
        return _CSLib.istream_ignore(self, *args)

    def peek(self):
        return _CSLib.istream_peek(self)

    def read(self, __s, __n):
        return _CSLib.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _CSLib.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _CSLib.istream_putback(self, __c)

    def unget(self):
        return _CSLib.istream_unget(self)

    def sync(self):
        return _CSLib.istream_sync(self)

    def tellg(self):
        return _CSLib.istream_tellg(self)

    def seekg(self, *args):
        return _CSLib.istream_seekg(self, *args)

# Register istream in _CSLib:
_CSLib.istream_swigregister(istream)
class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CSLib.iostream_swiginit(self, _CSLib.new_iostream(__sb))
    __swig_destroy__ = _CSLib.delete_iostream

# Register iostream in _CSLib:
_CSLib.iostream_swigregister(iostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

endl_cb_ptr = _CSLib.endl_cb_ptr
endl = _CSLib.endl
ends_cb_ptr = _CSLib.ends_cb_ptr
ends = _CSLib.ends
flush_cb_ptr = _CSLib.flush_cb_ptr
flush = _CSLib.flush
import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD

from enum import IntEnum
from OCC.Core.Exception import *

CSLib_Done = _CSLib.CSLib_Done
CSLib_D1uIsNull = _CSLib.CSLib_D1uIsNull
CSLib_D1vIsNull = _CSLib.CSLib_D1vIsNull
CSLib_D1IsNull = _CSLib.CSLib_D1IsNull
CSLib_D1uD1vRatioIsNull = _CSLib.CSLib_D1uD1vRatioIsNull
CSLib_D1vD1uRatioIsNull = _CSLib.CSLib_D1vD1uRatioIsNull
CSLib_D1uIsParallelD1v = _CSLib.CSLib_D1uIsParallelD1v
CSLib_Singular = _CSLib.CSLib_Singular
CSLib_Defined = _CSLib.CSLib_Defined
CSLib_InfinityOfSolutions = _CSLib.CSLib_InfinityOfSolutions
CSLib_D1NuIsNull = _CSLib.CSLib_D1NuIsNull
CSLib_D1NvIsNull = _CSLib.CSLib_D1NvIsNull
CSLib_D1NIsNull = _CSLib.CSLib_D1NIsNull
CSLib_D1NuNvRatioIsNull = _CSLib.CSLib_D1NuNvRatioIsNull
CSLib_D1NvNuRatioIsNull = _CSLib.CSLib_D1NvNuRatioIsNull
CSLib_D1NuIsParallelD1Nv = _CSLib.CSLib_D1NuIsParallelD1Nv


class CSLib_DerivativeStatus(IntEnum):
	CSLib_Done = 0
	CSLib_D1uIsNull = 1
	CSLib_D1vIsNull = 2
	CSLib_D1IsNull = 3
	CSLib_D1uD1vRatioIsNull = 4
	CSLib_D1vD1uRatioIsNull = 5
	CSLib_D1uIsParallelD1v = 6
CSLib_Done = CSLib_DerivativeStatus.CSLib_Done
CSLib_D1uIsNull = CSLib_DerivativeStatus.CSLib_D1uIsNull
CSLib_D1vIsNull = CSLib_DerivativeStatus.CSLib_D1vIsNull
CSLib_D1IsNull = CSLib_DerivativeStatus.CSLib_D1IsNull
CSLib_D1uD1vRatioIsNull = CSLib_DerivativeStatus.CSLib_D1uD1vRatioIsNull
CSLib_D1vD1uRatioIsNull = CSLib_DerivativeStatus.CSLib_D1vD1uRatioIsNull
CSLib_D1uIsParallelD1v = CSLib_DerivativeStatus.CSLib_D1uIsParallelD1v

class CSLib_NormalStatus(IntEnum):
	CSLib_Singular = 0
	CSLib_Defined = 1
	CSLib_InfinityOfSolutions = 2
	CSLib_D1NuIsNull = 3
	CSLib_D1NvIsNull = 4
	CSLib_D1NIsNull = 5
	CSLib_D1NuNvRatioIsNull = 6
	CSLib_D1NvNuRatioIsNull = 7
	CSLib_D1NuIsParallelD1Nv = 8
CSLib_Singular = CSLib_NormalStatus.CSLib_Singular
CSLib_Defined = CSLib_NormalStatus.CSLib_Defined
CSLib_InfinityOfSolutions = CSLib_NormalStatus.CSLib_InfinityOfSolutions
CSLib_D1NuIsNull = CSLib_NormalStatus.CSLib_D1NuIsNull
CSLib_D1NvIsNull = CSLib_NormalStatus.CSLib_D1NvIsNull
CSLib_D1NIsNull = CSLib_NormalStatus.CSLib_D1NIsNull
CSLib_D1NuNvRatioIsNull = CSLib_NormalStatus.CSLib_D1NuNvRatioIsNull
CSLib_D1NvNuRatioIsNull = CSLib_NormalStatus.CSLib_D1NvNuRatioIsNull
CSLib_D1NuIsParallelD1Nv = CSLib_NormalStatus.CSLib_D1NuIsParallelD1Nv

class cslib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def DNNUV(*args):
        r"""

        Parameters
        ----------
        Nu: int
        Nv: int
        DerSurf: TColgp_Array2OfVec

        Return
        -------
        gp_Vec

        Description
        -----------
        -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the not -- normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1.

        Parameters
        ----------
        Nu: int
        Nv: int
        DerSurf1: TColgp_Array2OfVec
        DerSurf2: TColgp_Array2OfVec

        Return
        -------
        gp_Vec

        Description
        -----------
        Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1.

        """
        return _CSLib.cslib_DNNUV(*args)

    @staticmethod
    def DNNormal(*args):
        r"""

        Parameters
        ----------
        Nu: int
        Nv: int
        DerNUV: TColgp_Array2OfVec
        Iduref: int (optional, default to 0)
        Idvref: int (optional, default to 0)

        Return
        -------
        gp_Vec

        Description
        -----------
        -- Computes the derivative of order Nu in the -- direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.

        """
        return _CSLib.cslib_DNNormal(*args)

    @staticmethod
    def Normal(*args):
        r"""

        Parameters
        ----------
        D1U: gp_Vec
        D1V: gp_Vec
        SinTol: float
        Normal: gp_Dir

        Return
        -------
        theStatus: CSLib_DerivativeStatus

        Description
        -----------
        The following functions computes the normal to a surface inherits FunctionWithDerivative from math //! Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if theStatus == Done else the theStatus gives the reason why the computation has failed.

        Parameters
        ----------
        D1U: gp_Vec
        D1V: gp_Vec
        D2U: gp_Vec
        D2V: gp_Vec
        D2UV: gp_Vec
        SinTol: float
        Normal: gp_Dir

        Return
        -------
        Done: bool
        theStatus: CSLib_NormalStatus

        Description
        -----------
        If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approached normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow: N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| //! . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited development at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.

        Parameters
        ----------
        D1U: gp_Vec
        D1V: gp_Vec
        MagTol: float
        Normal: gp_Dir

        Return
        -------
        theStatus: CSLib_NormalStatus

        Description
        -----------
        Computes the normal direction of a surface as the cross product between D1U and D1V.

        Parameters
        ----------
        MaxOrder: int
        DerNUV: TColgp_Array2OfVec
        MagTol: float
        U: float
        V: float
        Umin: float
        Umax: float
        Vmin: float
        Vmax: float
        Normal: gp_Dir

        Return
        -------
        theStatus: CSLib_NormalStatus
        OrderU: int
        OrderV: int

        Description
        -----------
        find the first order k0 of deriviative of NUV where: foreach order < k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.

        """
        return _CSLib.cslib_Normal(*args)

    __repr__ = _dumps_object


    def __init__(self):
        _CSLib.cslib_swiginit(self, _CSLib.new_cslib())
    __swig_destroy__ = _CSLib.delete_cslib

# Register cslib in _CSLib:
_CSLib.cslib_swigregister(cslib)
class CSLib_Class2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        thePnts2d: TColgp_Array1OfPnt2d
        theTolU: float
        theTolV: float
        theUMin: float
        theVMin: float
        theUMax: float
        theVMax: float

        Return
        -------
        None

        Description
        -----------
        Constructs the 2D-polygon. thePnts2d is the set of the vertices (closed polygon will always be created inside of this constructor; consequently, there is no point in repeating first and last point in thePnts2d). theTolu and theTolv are tolerances. theUmin, theVmin, theUmax, theVmax are UV-bounds of the polygon.

        Parameters
        ----------
        thePnts2d: TColgp_SequenceOfPnt2d
        theTolU: float
        theTolV: float
        theUMin: float
        theVMin: float
        theUMax: float
        theVMax: float

        Return
        -------
        None

        Description
        -----------
        Constructs the 2D-polygon. thePnts2d is the set of the vertices (closed polygon will always be created inside of this constructor; consequently, there is no point in repeating first and last point in thePnts2d). theTolu and theTolv are tolerances. theUmin, theVmin, theUmax, theVmax are UV-bounds of the polygon.

        """
        _CSLib.CSLib_Class2d_swiginit(self, _CSLib.new_CSLib_Class2d(*args))

    def InternalSiDans(self, *args):
        r"""

        Parameters
        ----------
        X: float
        Y: float

        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _CSLib.CSLib_Class2d_InternalSiDans(self, *args)

    def InternalSiDansOuOn(self, *args):
        r"""

        Parameters
        ----------
        X: float
        Y: float

        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _CSLib.CSLib_Class2d_InternalSiDansOuOn(self, *args)

    def SiDans(self, *args):
        r"""

        Parameters
        ----------
        P: gp_Pnt2d

        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _CSLib.CSLib_Class2d_SiDans(self, *args)

    def SiDans_OnMode(self, *args):
        r"""

        Parameters
        ----------
        P: gp_Pnt2d
        Tol: float

        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _CSLib.CSLib_Class2d_SiDans_OnMode(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CSLib.delete_CSLib_Class2d

# Register CSLib_Class2d in _CSLib:
_CSLib.CSLib_Class2d_swigregister(CSLib_Class2d)
class CSLib_NormalPolyDef(OCC.Core.math.math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        k0: int
        li: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _CSLib.CSLib_NormalPolyDef_swiginit(self, _CSLib.new_CSLib_NormalPolyDef(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _CSLib.delete_CSLib_NormalPolyDef

# Register CSLib_NormalPolyDef in _CSLib:
_CSLib.CSLib_NormalPolyDef_swigregister(CSLib_NormalPolyDef)



@deprecated
def cslib_DNNUV(*args):
	return cslib.DNNUV(*args)

@deprecated
def cslib_DNNUV(*args):
	return cslib.DNNUV(*args)

@deprecated
def cslib_DNNormal(*args):
	return cslib.DNNormal(*args)

@deprecated
def cslib_Normal(*args):
	return cslib.Normal(*args)

@deprecated
def cslib_Normal(*args):
	return cslib.Normal(*args)

@deprecated
def cslib_Normal(*args):
	return cslib.Normal(*args)

@deprecated
def cslib_Normal(*args):
	return cslib.Normal(*args)



