# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
math module, see official documentation at
https://dev.opencascade.org/doc/occt-7.9.0/refman/html/package_math.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _math
else:
    import _math

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math.delete_SwigPyIterator

    def value(self):
        return _math.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _math.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _math.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _math.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _math.SwigPyIterator_equal(self, x)

    def copy(self):
        return _math.SwigPyIterator_copy(self)

    def next(self):
        return _math.SwigPyIterator_next(self)

    def __next__(self):
        return _math.SwigPyIterator___next__(self)

    def previous(self):
        return _math.SwigPyIterator_previous(self)

    def advance(self, n):
        return _math.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _math.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _math.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _math.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _math.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _math.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _math.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _math:
_math.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string

PYTHONOCC_DEBUG_EXCEPTIONS = _math.PYTHONOCC_DEBUG_EXCEPTIONS

def get_readable_class_name(class_name):
    return _math.get_readable_class_name(class_name)

def get_readable_method_name(method_name):
    return _math.get_readable_method_name(method_name)

def get_exception_type(error):
    return _math.get_exception_type(error)

def process_opencascade_exception(error, method_name, class_name):
    return _math.process_opencascade_exception(error, method_name, class_name)

import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _math.ios_base_erase_event
    imbue_event = _math.ios_base_imbue_event
    copyfmt_event = _math.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _math.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _math.ios_base_flags(self, *args)

    def setf(self, *args):
        return _math.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _math.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _math.ios_base_precision(self, *args)

    def width(self, *args):
        return _math.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _math.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _math.ios_base_imbue(self, __loc)

    def getloc(self):
        return _math.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _math.ios_base_xalloc()

    def iword(self, __ix):
        return _math.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _math.ios_base_pword(self, __ix)
    __swig_destroy__ = _math.delete_ios_base

# Register ios_base in _math:
_math.ios_base_swigregister(ios_base)
cvar = _math.cvar
ios_base.boolalpha = _math.cvar.ios_base_boolalpha
ios_base.dec = _math.cvar.ios_base_dec
ios_base.fixed = _math.cvar.ios_base_fixed
ios_base.hex = _math.cvar.ios_base_hex
ios_base.internal = _math.cvar.ios_base_internal
ios_base.left = _math.cvar.ios_base_left
ios_base.oct = _math.cvar.ios_base_oct
ios_base.right = _math.cvar.ios_base_right
ios_base.scientific = _math.cvar.ios_base_scientific
ios_base.showbase = _math.cvar.ios_base_showbase
ios_base.showpoint = _math.cvar.ios_base_showpoint
ios_base.showpos = _math.cvar.ios_base_showpos
ios_base.skipws = _math.cvar.ios_base_skipws
ios_base.unitbuf = _math.cvar.ios_base_unitbuf
ios_base.uppercase = _math.cvar.ios_base_uppercase
ios_base.adjustfield = _math.cvar.ios_base_adjustfield
ios_base.basefield = _math.cvar.ios_base_basefield
ios_base.floatfield = _math.cvar.ios_base_floatfield
ios_base.badbit = _math.cvar.ios_base_badbit
ios_base.eofbit = _math.cvar.ios_base_eofbit
ios_base.failbit = _math.cvar.ios_base_failbit
ios_base.goodbit = _math.cvar.ios_base_goodbit
ios_base.app = _math.cvar.ios_base_app
ios_base.ate = _math.cvar.ios_base_ate
ios_base.binary = _math.cvar.ios_base_binary
ios_base.ios_base_in = _math.cvar.ios_base_ios_base_in
ios_base.out = _math.cvar.ios_base_out
ios_base.trunc = _math.cvar.ios_base_trunc
ios_base.beg = _math.cvar.ios_base_beg
ios_base.cur = _math.cvar.ios_base_cur
ios_base.end = _math.cvar.ios_base_end

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _math.ios_rdstate(self)

    def clear(self, *args):
        return _math.ios_clear(self, *args)

    def setstate(self, __state):
        return _math.ios_setstate(self, __state)

    def good(self):
        return _math.ios_good(self)

    def eof(self):
        return _math.ios_eof(self)

    def fail(self):
        return _math.ios_fail(self)

    def bad(self):
        return _math.ios_bad(self)

    def exceptions(self, *args):
        return _math.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _math.ios_swiginit(self, _math.new_ios(__sb))
    __swig_destroy__ = _math.delete_ios

    def tie(self, *args):
        return _math.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _math.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _math.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _math.ios_fill(self, *args)

    def imbue(self, __loc):
        return _math.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _math.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _math.ios_widen(self, __c)

# Register ios in _math:
_math.ios_swigregister(ios)
class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _math.ostream_swiginit(self, _math.new_ostream(__sb))
    __swig_destroy__ = _math.delete_ostream

    def __lshift__(self, *args):
        return _math.ostream___lshift__(self, *args)

    def put(self, __c):
        return _math.ostream_put(self, __c)

    def write(self, __s, __n):
        return _math.ostream_write(self, __s, __n)

    def flush(self):
        return _math.ostream_flush(self)

    def tellp(self):
        return _math.ostream_tellp(self)

    def seekp(self, *args):
        return _math.ostream_seekp(self, *args)

# Register ostream in _math:
_math.ostream_swigregister(ostream)
class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _math.istream_swiginit(self, _math.new_istream(__sb))
    __swig_destroy__ = _math.delete_istream

    def __rshift__(self, *args):
        return _math.istream___rshift__(self, *args)

    def gcount(self):
        return _math.istream_gcount(self)

    def get(self, *args):
        return _math.istream_get(self, *args)

    def getline(self, *args):
        return _math.istream_getline(self, *args)

    def ignore(self, *args):
        return _math.istream_ignore(self, *args)

    def peek(self):
        return _math.istream_peek(self)

    def read(self, __s, __n):
        return _math.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _math.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _math.istream_putback(self, __c)

    def unget(self):
        return _math.istream_unget(self)

    def sync(self):
        return _math.istream_sync(self)

    def tellg(self):
        return _math.istream_tellg(self)

    def seekg(self, *args):
        return _math.istream_seekg(self, *args)

# Register istream in _math:
_math.istream_swigregister(istream)
class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _math.iostream_swiginit(self, _math.new_iostream(__sb))
    __swig_destroy__ = _math.delete_iostream

# Register iostream in _math:
_math.iostream_swigregister(iostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

endl_cb_ptr = _math.endl_cb_ptr
endl = _math.endl
ends_cb_ptr = _math.ends_cb_ptr
ends = _math.ends
flush_cb_ptr = _math.flush_cb_ptr
flush = _math.flush
import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

class math_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Init(self, theInitialValue):
        return _math.math_Vector_Init(self, theInitialValue)

    def __init__(self, *args):
        _math.math_Vector_swiginit(self, _math.new_math_Vector(*args))

    def Length(self):
        return _math.math_Vector_Length(self)

    def Lower(self):
        return _math.math_Vector_Lower(self)

    def Upper(self):
        return _math.math_Vector_Upper(self)

    def Norm(self):
        return _math.math_Vector_Norm(self)

    def Norm2(self):
        return _math.math_Vector_Norm2(self)

    def Max(self):
        return _math.math_Vector_Max(self)

    def Min(self):
        return _math.math_Vector_Min(self)

    def Normalize(self):
        return _math.math_Vector_Normalize(self)

    def Normalized(self):
        return _math.math_Vector_Normalized(self)

    def Invert(self):
        return _math.math_Vector_Invert(self)

    def Inverse(self):
        return _math.math_Vector_Inverse(self)

    def Slice(self, theI1, theI2):
        return _math.math_Vector_Slice(self, theI1, theI2)

    def __imul__(self, theRight):
        return _math.math_Vector___imul__(self, theRight)

    def TMultiplied(self, theRight):
        return _math.math_Vector_TMultiplied(self, theRight)

    def Divide(self, theRight):
        return _math.math_Vector_Divide(self, theRight)

    def __itruediv__(self, *args):
        return _math.math_Vector___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, theRight):
        return _math.math_Vector_Divided(self, theRight)

    def __truediv__(self, *args):
        return _math.math_Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, theRight):
        return _math.math_Vector___iadd__(self, theRight)

    def Added(self, theRight):
        return _math.math_Vector_Added(self, theRight)

    def __add__(self, theRight):
        return _math.math_Vector___add__(self, theRight)

    def TMultiply(self, *args):
        return _math.math_Vector_TMultiply(self, *args)

    def Add(self, *args):
        return _math.math_Vector_Add(self, *args)

    def Value(self, *args):
        return _math.math_Vector_Value(self, *args)

    def __call__(self, *args):
        return _math.math_Vector___call__(self, *args)

    def Initialized(self, theOther):
        return _math.math_Vector_Initialized(self, theOther)

    def Set(self, *args):
        return _math.math_Vector_Set(self, *args)

    def Multiplied(self, *args):
        return _math.math_Vector_Multiplied(self, *args)

    def __mul__(self, *args):
        return _math.math_Vector___mul__(self, *args)

    def Opposite(self):
        return _math.math_Vector_Opposite(self)

    def __neg__(self):
        return _math.math_Vector___neg__(self)

    def Subtract(self, *args):
        return _math.math_Vector_Subtract(self, *args)

    def __isub__(self, theRight):
        return _math.math_Vector___isub__(self, theRight)

    def Subtracted(self, theRight):
        return _math.math_Vector_Subtracted(self, theRight)

    def __sub__(self, theRight):
        return _math.math_Vector___sub__(self, theRight)

    def Multiply(self, *args):
        return _math.math_Vector_Multiply(self, *args)

    def Dump(self, theO):
        return _math.math_Vector_Dump(self, theO)
    __swig_destroy__ = _math.delete_math_Vector

# Register math_Vector in _math:
_math.math_Vector_swigregister(math_Vector)
math_OK = _math.math_OK
math_TooManyIterations = _math.math_TooManyIterations
math_FunctionError = _math.math_FunctionError
math_DirectionSearchError = _math.math_DirectionSearchError
math_NotBracketed = _math.math_NotBracketed


class math_Status(IntEnum):
	math_OK = 0
	math_TooManyIterations = 1
	math_FunctionError = 2
	math_DirectionSearchError = 3
	math_NotBracketed = 4
math_OK = math_Status.math_OK
math_TooManyIterations = math_Status.math_TooManyIterations
math_FunctionError = math_Status.math_FunctionError
math_DirectionSearchError = math_Status.math_DirectionSearchError
math_NotBracketed = math_Status.math_NotBracketed

class math_Array1OfValueAndWeight(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self, *args):
        return _math.math_Array1OfValueAndWeight_begin(self, *args)

    def cbegin(self):
        return _math.math_Array1OfValueAndWeight_cbegin(self)

    def end(self, *args):
        return _math.math_Array1OfValueAndWeight_end(self, *args)

    def cend(self):
        return _math.math_Array1OfValueAndWeight_cend(self)

    def __init__(self, *args):
        _math.math_Array1OfValueAndWeight_swiginit(self, _math.new_math_Array1OfValueAndWeight(*args))
    __swig_destroy__ = _math.delete_math_Array1OfValueAndWeight

    def Init(self, theValue):
        return _math.math_Array1OfValueAndWeight_Init(self, theValue)

    def Size(self):
        return _math.math_Array1OfValueAndWeight_Size(self)

    def Length(self):
        return _math.math_Array1OfValueAndWeight_Length(self)

    def IsEmpty(self):
        return _math.math_Array1OfValueAndWeight_IsEmpty(self)

    def Lower(self):
        return _math.math_Array1OfValueAndWeight_Lower(self)

    def Upper(self):
        return _math.math_Array1OfValueAndWeight_Upper(self)

    def Assign(self, theOther):
        return _math.math_Array1OfValueAndWeight_Assign(self, theOther)

    def Move(self, *args):
        return _math.math_Array1OfValueAndWeight_Move(self, *args)

    def Set(self, *args):
        return _math.math_Array1OfValueAndWeight_Set(self, *args)

    def First(self):
        return _math.math_Array1OfValueAndWeight_First(self)

    def ChangeFirst(self):
        return _math.math_Array1OfValueAndWeight_ChangeFirst(self)

    def Last(self):
        return _math.math_Array1OfValueAndWeight_Last(self)

    def ChangeLast(self):
        return _math.math_Array1OfValueAndWeight_ChangeLast(self)

    def Value(self, theIndex):
        return _math.math_Array1OfValueAndWeight_Value(self, theIndex)

    def ChangeValue(self, theIndex):
        return _math.math_Array1OfValueAndWeight_ChangeValue(self, theIndex)

    def __call__(self, *args):
        return _math.math_Array1OfValueAndWeight___call__(self, *args)

    def SetValue(self, *args):
        return _math.math_Array1OfValueAndWeight_SetValue(self, *args)

    def UpdateLowerBound(self, theLower):
        return _math.math_Array1OfValueAndWeight_UpdateLowerBound(self, theLower)

    def UpdateUpperBound(self, theUpper):
        return _math.math_Array1OfValueAndWeight_UpdateUpperBound(self, theUpper)

    def Resize(self, theLower, theUpper, theToCopyData):
        return _math.math_Array1OfValueAndWeight_Resize(self, theLower, theUpper, theToCopyData)

    def IsDeletable(self):
        return _math.math_Array1OfValueAndWeight_IsDeletable(self)

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next


# Register math_Array1OfValueAndWeight in _math:
_math.math_Array1OfValueAndWeight_swigregister(math_Array1OfValueAndWeight)
class math(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GaussPoints(*args):
        r"""

        Parameters
        ----------
        Index: int
        Points: math_Vector

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_GaussPoints(*args)

    @staticmethod
    def GaussPointsMax(*args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _math.math_GaussPointsMax(*args)

    @staticmethod
    def GaussWeights(*args):
        r"""

        Parameters
        ----------
        Index: int
        Weights: math_Vector

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_GaussWeights(*args)

    @staticmethod
    def KronrodPointsAndWeights(*args):
        r"""

        Parameters
        ----------
        Index: int
        Points: math_Vector
        Weights: math_Vector

        Return
        -------
        bool

        Description
        -----------
        Returns a vector of Kronrod points and a vector of their weights for Gauss-Kronrod computation method. Index should be odd and greater then or equal to 3, as the number of Kronrod points is equal to 2*N + 1, where N is a number of Gauss points. Points and Weights should have the size equal to Index. Each even element of Points represents a Gauss point value of N-th Gauss quadrature. The values from Index equal to 3 to 123 are stored in a table (see the file math_Kronrod.cxx). If Index is greater, then points and weights will be computed. Returns Standard_True if Index is odd, it is equal to the size of Points and Weights and the computation of Points and Weights is performed successfully. Otherwise this method returns Standard_False.

        """
        return _math.math_KronrodPointsAndWeights(*args)

    @staticmethod
    def KronrodPointsMax(*args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the maximal number of points for that the values are stored in the table. If the number is greater then KronrodPointsMax, the points will be computed.

        """
        return _math.math_KronrodPointsMax(*args)

    @staticmethod
    def OrderedGaussPointsAndWeights(*args):
        r"""

        Parameters
        ----------
        Index: int
        Points: math_Vector
        Weights: math_Vector

        Return
        -------
        bool

        Description
        -----------
        Returns a vector of Gauss points and a vector of their weights. The difference with the method GaussPoints is the following: - the points are returned in increasing order. - if Index is greater then GaussPointsMax, the points are computed. Returns Standard_True if Index is positive, Points' and Weights' length is equal to Index, Points and Weights are successfully computed.

        """
        return _math.math_OrderedGaussPointsAndWeights(*args)

    __repr__ = _dumps_object


    def __init__(self):
        _math.math_swiginit(self, _math.new_math())
    __swig_destroy__ = _math.delete_math

# Register math in _math:
_math.math_swigregister(math)
class math_BFGS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        NbVariables: int
        Tolerance: float (optional, default to 1.0e-8)
        NbIterations: int (optional, default to 200)
        ZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        Initializes the computation of the minimum of a function with NbVariables. Tolerance, ZEPS and NbIterations are described in the method Perform. Warning: A call to the Perform method must be made after this initialization to effectively compute the minimum of the function F.

        """
        _math.math_BFGS_swiginit(self, _math.new_math_BFGS(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_BFGS_Dump(self, *args)

    def Gradient(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the gradient vector at the minimum. Exception NotDone is raised if the minimum was not found.

        Parameters
        ----------
        Grad: math_Vector

        Return
        -------
        None

        Description
        -----------
        Returns the value of the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.

        """
        return _math.math_BFGS_Gradient(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_BFGS_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient

        Return
        -------
        bool

        Description
        -----------
        This method is called at the end of each iteration to check if the solution is found. It can be redefined in a sub-class to implement a specific test to stop the iterations.

        """
        return _math.math_BFGS_IsSolutionReached(self, *args)

    def Location(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.

        Parameters
        ----------
        Loc: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.

        """
        return _math.math_BFGS_Location(self, *args)

    def Minimum(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BFGS_Minimum(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations really done in the calculation of the minimum. The exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BFGS_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector

        Return
        -------
        None

        Description
        -----------
        Given the starting point StartingPoint, minimization is done on the function F. The solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS). Tolerance, ZEPS and maximum number of iterations are given in the constructor.

        """
        return _math.math_BFGS_Perform(self, *args)

    def SetBoundary(self, *args):
        r"""

        Parameters
        ----------
        theLeftBorder: math_Vector
        theRightBorder: math_Vector

        Return
        -------
        None

        Description
        -----------
        Set boundaries for conditional optimization. The expected indices range of vectors is [1, NbVariables].

        """
        return _math.math_BFGS_SetBoundary(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BFGS

# Register math_BFGS in _math:
_math.math_BFGS_swigregister(math_BFGS)
class math_BissecNewton(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theXTolerance: float

        Return
        -------
        None

        Description
        -----------
        Constructor. 
        Parameter theXTolerance - algorithm tolerance.

        """
        _math.math_BissecNewton_swiginit(self, _math.new_math_BissecNewton(*args))

    def Derivative(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the derivative at the root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BissecNewton_Derivative(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_BissecNewton_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Tests is the root has been successfully found.

        """
        return _math.math_BissecNewton_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_FunctionWithDerivative

        Return
        -------
        bool

        Description
        -----------
        This method is called at the end of each iteration to check if the solution has been found. It can be redefined in a sub-class to implement a specific test to stop the iterations.

        """
        return _math.math_BissecNewton_IsSolutionReached(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Bound1: float
        Bound2: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        A combination of Newton-Raphson and bissection methods is done to find the root of the function F between the bounds Bound1 and Bound2 on the function F. The tolerance required on the root is given by TolX. The solution is found when: abs(Xi - Xi-1) <= TolX and F(Xi) * F(Xi-1) <= 0 The maximum number of iterations allowed is given by NbIterations.

        """
        return _math.math_BissecNewton_Perform(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BissecNewton_Root(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the function at the root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BissecNewton_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BissecNewton

# Register math_BissecNewton in _math:
_math.math_BissecNewton_swigregister(math_BissecNewton)
class math_BracketMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float

        Return
        -------
        None

        Description
        -----------
        Constructor preparing A and B parameters only. It does not perform the job.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float

        Return
        -------
        None

        Description
        -----------
        Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float
        FA: float

        Return
        -------
        None

        Description
        -----------
        Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) is known.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float
        FA: float
        FB: float

        Return
        -------
        None

        Description
        -----------
        Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) and F(B) are known.

        """
        _math.math_BracketMinimum_swiginit(self, _math.new_math_BracketMinimum(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_BracketMinimum_Dump(self, *args)

    def FunctionValues(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        FA: float
        FB: float
        FC: float

        Description
        -----------
        returns the bracketed triplet function values. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_BracketMinimum_FunctionValues(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_BracketMinimum_IsDone(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        F: math_Function

        Return
        -------
        None

        Description
        -----------
        The method performing the job. It is called automatically by constructors with the function.

        """
        return _math.math_BracketMinimum_Perform(self, *args)

    def SetFA(self, *args):
        r"""

        Parameters
        ----------
        theValue: float

        Return
        -------
        None

        Description
        -----------
        Set function value at A.

        """
        return _math.math_BracketMinimum_SetFA(self, *args)

    def SetFB(self, *args):
        r"""

        Parameters
        ----------
        theValue: float

        Return
        -------
        None

        Description
        -----------
        Set function value at B.

        """
        return _math.math_BracketMinimum_SetFB(self, *args)

    def SetLimits(self, *args):
        r"""

        Parameters
        ----------
        theLeft: float
        theRight: float

        Return
        -------
        None

        Description
        -----------
        Set limits of the parameter. By default no limits are applied to the parameter change. If no minimum is found in limits then IsDone() will return false. The user is in charge of providing A and B to be in limits.

        """
        return _math.math_BracketMinimum_SetLimits(self, *args)

    def Values(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        A: float
        B: float
        C: float

        Description
        -----------
        Returns the bracketed triplet of abscissae. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_BracketMinimum_Values(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketMinimum

# Register math_BracketMinimum in _math:
_math.math_BracketMinimum_swigregister(math_BracketMinimum)
class math_BracketedRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_Function
        Bound1: float
        Bound2: float
        Tolerance: float
        NbIterations: int (optional, default to 100)
        ZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        The Brent method is used to find the root of the function F between the bounds Bound1 and Bound2 on the function F. If F(Bound1)*F(Bound2) >0 the Brent method fails. The tolerance required for the root is given by Tolerance. The solution is found when: abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.

        """
        _math.math_BracketedRoot_swiginit(self, _math.new_math_BracketedRoot(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object.

        """
        return _math.math_BracketedRoot_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_BracketedRoot_IsDone(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done during the computation of the Root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BracketedRoot_NbIterations(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BracketedRoot_Root(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the function at the root. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BracketedRoot_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketedRoot

# Register math_BracketedRoot in _math:
_math.math_BracketedRoot_swigregister(math_BracketedRoot)
class math_BrentMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        TolX: float
        NbIterations: int (optional, default to 100)
        ZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        This constructor should be used in a sub-class to initialize correctly all the fields of this class.

        Parameters
        ----------
        TolX: float
        Fbx: float
        NbIterations: int (optional, default to 100)
        ZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        This constructor should be used in a sub-class to initialize correctly all the fields of this class. It has to be used if F(Bx) is known.

        """
        _math.math_BrentMinimum_swiginit(self, _math.new_math_BrentMinimum(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_BrentMinimum_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_BrentMinimum_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_Function

        Return
        -------
        bool

        Description
        -----------
        This method is called at the end of each iteration to check if the solution is found. It can be redefined in a sub-class to implement a specific test to stop the iterations.

        """
        return _math.math_BrentMinimum_IsSolutionReached(self, *args)

    def Location(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the location value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BrentMinimum_Location(self, *args)

    def Minimum(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BrentMinimum_Minimum(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_BrentMinimum_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        F: math_Function
        Ax: float
        Bx: float
        Cx: float

        Return
        -------
        None

        Description
        -----------
        Brent minimization is performed on function F from a given bracketing triplet of abscissas Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) The solution is found when: abs(Xi - Xi-1) <= TolX * abs(Xi) + ZEPS;.

        """
        return _math.math_BrentMinimum_Perform(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BrentMinimum

# Register math_BrentMinimum in _math:
_math.math_BrentMinimum_swigregister(math_BrentMinimum)
class math_BullardGenerator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theSeed: unsigned int (optional, default to 1)

        Return
        -------
        None

        Description
        -----------
        Creates new Xorshift 64-bit RNG.

        """
        _math.math_BullardGenerator_swiginit(self, _math.new_math_BullardGenerator(*args))

    def NextInt(self, *args):
        r"""
        Return
        -------
        unsigned int

        Description
        -----------
        Generates new 64-bit integer value.

        """
        return _math.math_BullardGenerator_NextInt(self, *args)

    def NextReal(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Generates new floating-point value.

        """
        return _math.math_BullardGenerator_NextReal(self, *args)

    def SetSeed(self, *args):
        r"""

        Parameters
        ----------
        theSeed: unsigned int (optional, default to 1)

        Return
        -------
        None

        Description
        -----------
        Setup new seed / reset defaults.

        """
        return _math.math_BullardGenerator_SetSeed(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BullardGenerator

# Register math_BullardGenerator in _math:
_math.math_BullardGenerator_swigregister(math_BullardGenerator)
class math_ComputeGaussPointsAndWeights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Number: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_ComputeGaussPointsAndWeights_swiginit(self, _math.new_math_ComputeGaussPointsAndWeights(*args))

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeGaussPointsAndWeights_IsDone(self, *args)

    def Points(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeGaussPointsAndWeights_Points(self, *args)

    def Weights(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeGaussPointsAndWeights_Weights(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeGaussPointsAndWeights

# Register math_ComputeGaussPointsAndWeights in _math:
_math.math_ComputeGaussPointsAndWeights_swigregister(math_ComputeGaussPointsAndWeights)
class math_ComputeKronrodPointsAndWeights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Number: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_ComputeKronrodPointsAndWeights_swiginit(self, _math.new_math_ComputeKronrodPointsAndWeights(*args))

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeKronrodPointsAndWeights_IsDone(self, *args)

    def Points(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeKronrodPointsAndWeights_Points(self, *args)

    def Weights(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        No available documentation.

        """
        return _math.math_ComputeKronrodPointsAndWeights_Weights(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeKronrodPointsAndWeights

# Register math_ComputeKronrodPointsAndWeights in _math:
_math.math_ComputeKronrodPointsAndWeights_swigregister(math_ComputeKronrodPointsAndWeights)
class math_Crout(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float (optional, default to 1.0e-20)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix A, this algorithm inverts A by the Crout algorithm. The user can give only the inferior triangle for the implementation. A can be decomposed like this: A = L * D * T(L) where L is triangular inferior and D is diagonal. If one element of A is less than MinPivot, A is considered as singular. Exception NotSquare is raised if A is not a square matrix.

        """
        _math.math_Crout_swiginit(self, _math.new_math_Crout(*args))

    def Determinant(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the determinant of the previously LU decomposed matrix A. Zero is returned if the matrix A is considered as singular. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_Crout_Determinant(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object.

        """
        return _math.math_Crout_Dump(self, *args)

    def Inverse(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        returns the inverse matrix of A. Only the inferior triangle is returned. Exception NotDone is raised if NotDone.

        """
        return _math.math_Crout_Inverse(self, *args)

    def Invert(self, *args):
        r"""

        Parameters
        ----------
        Inv: math_Matrix

        Return
        -------
        None

        Description
        -----------
        returns in Inv the inverse matrix of A. Only the inferior triangle is returned. Exception NotDone is raised if NotDone.

        """
        return _math.math_Crout_Invert(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns True if all has been correctly done.

        """
        return _math.math_Crout_IsDone(self, *args)

    def Solve(self, *args):
        r"""

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Return
        -------
        None

        Description
        -----------
        Given an input vector <B>, this routine returns the solution of the set of linear equations A . X = B. Exception NotDone is raised if the decomposition was not done successfully. Exception DimensionError is raised if the range of B is not equal to the rowrange of A.

        """
        return _math.math_Crout_Solve(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Crout

# Register math_Crout in _math:
_math.math_Crout_swigregister(math_Crout)
class math_DirectPolynomialRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float

        Return
        -------
        None

        Description
        -----------
        computes all the real roots of the polynomial Ax4 + Bx3 + Cx2 + Dx + E using a direct method.

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float

        Return
        -------
        None

        Description
        -----------
        computes all the real roots of the polynomial Ax3 + Bx2 + Cx + D using a direct method.

        Parameters
        ----------
        A: float
        B: float
        C: float

        Return
        -------
        None

        Description
        -----------
        computes all the real roots of the polynomial Ax2 + Bx + C using a direct method.

        Parameters
        ----------
        A: float
        B: float

        Return
        -------
        None

        Description
        -----------
        computes the real root of the polynomial Ax + B.

        """
        _math.math_DirectPolynomialRoots_swiginit(self, _math.new_math_DirectPolynomialRoots(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_DirectPolynomialRoots_Dump(self, *args)

    def InfiniteRoots(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if there is an infinity of roots, otherwise returns false.

        """
        return _math.math_DirectPolynomialRoots_InfiniteRoots(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_DirectPolynomialRoots_IsDone(self, *args)

    def NbSolutions(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of solutions. An exception is raised if there are an infinity of roots.

        """
        return _math.math_DirectPolynomialRoots_NbSolutions(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        Nieme: int

        Return
        -------
        float

        Description
        -----------
        returns the value of the Nieme root. An exception is raised if there are an infinity of roots. Exception RangeError is raised if Nieme is < 1 or Nieme > NbSolutions.

        """
        return _math.math_DirectPolynomialRoots_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DirectPolynomialRoots

# Register math_DirectPolynomialRoots in _math:
_math.math_DirectPolynomialRoots_swigregister(math_DirectPolynomialRoots)
class math_DoubleTab(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        Tab: Standard_Address
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        Other: math_DoubleTab

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_DoubleTab_swiginit(self, _math.new_math_DoubleTab(*args))

    def Copy(self, *args):
        r"""

        Parameters
        ----------
        Other: math_DoubleTab

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_DoubleTab_Copy(self, *args)

    def Free(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_DoubleTab_Free(self, *args)

    def Init(self, *args):
        r"""

        Parameters
        ----------
        InitValue: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_DoubleTab_Init(self, *args)

    def SetLowerCol(self, *args):
        r"""

        Parameters
        ----------
        LowerCol: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_DoubleTab_SetLowerCol(self, *args)

    def SetLowerRow(self, *args):
        r"""

        Parameters
        ----------
        LowerRow: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _math.math_DoubleTab_SetLowerRow(self, *args)

    def GetValue(self, RowIndex, ColIndex):
        r"""GetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex) -> Standard_Real"""
        return _math.math_DoubleTab_GetValue(self, RowIndex, ColIndex)

    def SetValue(self, RowIndex, ColIndex, value):
        r"""SetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex, Standard_Real value)"""
        return _math.math_DoubleTab_SetValue(self, RowIndex, ColIndex, value)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DoubleTab

# Register math_DoubleTab in _math:
_math.math_DoubleTab_swigregister(math_DoubleTab)
class math_EigenValuesSearcher(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Diagonal: TColStd_Array1OfReal
        Subdiagonal: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_EigenValuesSearcher_swiginit(self, _math.new_math_EigenValuesSearcher(*args))

    def Dimension(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the dimension of matrix.

        """
        return _math.math_EigenValuesSearcher_Dimension(self, *args)

    def EigenValue(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the Index_th eigen value of matrix Index must be in [1, Dimension()].

        """
        return _math.math_EigenValuesSearcher_EigenValue(self, *args)

    def EigenVector(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        math_Vector

        Description
        -----------
        Returns the Index_th eigen vector of matrix Index must be in [1, Dimension()].

        """
        return _math.math_EigenValuesSearcher_EigenVector(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns Standard_True if computation is performed successfully.

        """
        return _math.math_EigenValuesSearcher_IsDone(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_EigenValuesSearcher

# Register math_EigenValuesSearcher in _math:
_math.math_EigenValuesSearcher_swigregister(math_EigenValuesSearcher)
class math_FRPR(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient
        theTolerance: float
        theNbIterations: int (optional, default to 200)
        theZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        Initializes the computation of the minimum of F. Warning: constructor does not perform computations.

        """
        _math.math_FRPR_swiginit(self, _math.new_math_FRPR(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_FRPR_Dump(self, *args)

    def Gradient(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the gradient vector at the minimum. Exception NotDone is raised if the minimum was not found.

        Parameters
        ----------
        Grad: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.

        """
        return _math.math_FRPR_Gradient(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_FRPR_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient

        Return
        -------
        bool

        Description
        -----------
        The solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS. The maximum number of iterations allowed is given by NbIterations.

        """
        return _math.math_FRPR_IsSolutionReached(self, *args)

    def Location(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.

        Parameters
        ----------
        Loc: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.

        """
        return _math.math_FRPR_Location(self, *args)

    def Minimum(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_FRPR_Minimum(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_FRPR_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient
        theStartingPoint: math_Vector

        Return
        -------
        None

        Description
        -----------
        The solution F = Fi is found when 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).

        """
        return _math.math_FRPR_Perform(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FRPR

# Register math_FRPR in _math:
_math.math_FRPR_swigregister(math_FRPR)
class math_Function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the state of the function corresponding to the latest call of any methods associated with the function. This function is called by each of the algorithms described later which defined the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.

        """
        return _math.math_Function_GetStateNumber(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        F: float

        Description
        -----------
        Computes the value of the function <F> for a given value of variable <X>. returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_Function_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Function

# Register math_Function in _math:
_math.math_Function_swigregister(math_Function)
class math_FunctionAllRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        S: math_FunctionSample
        EpsX: float
        EpsF: float
        EpsNul: float

        Return
        -------
        None

        Description
        -----------
        The algorithm uses the sample to find intervals on which the function is null. An interval is found if, for at least two consecutive points of the sample, Ui and Ui+1, we get |F(Ui)|<=EpsNul and |F(Ui+1)|<=EpsNul. The real bounds of an interval are computed with the FunctionRoots. algorithm. Between two intervals, the roots of the function F are calculated using the FunctionRoots algorithm.

        """
        _math.math_FunctionAllRoots_swiginit(self, _math.new_math_FunctionAllRoots(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object.

        """
        return _math.math_FunctionAllRoots_Dump(self, *args)

    def GetInterval(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        A: float
        B: float

        Description
        -----------
        Returns the interval of parameter of range Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.

        """
        return _math.math_FunctionAllRoots_GetInterval(self, *args)

    def GetIntervalState(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        IFirst: int
        ILast: int

        Description
        -----------
        returns the State Number associated to the interval Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.

        """
        return _math.math_FunctionAllRoots_GetIntervalState(self, *args)

    def GetPoint(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the parameter of the point of range Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >NbPoints.

        """
        return _math.math_FunctionAllRoots_GetPoint(self, *args)

    def GetPointState(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        int

        Description
        -----------
        returns the State Number associated to the point Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.

        """
        return _math.math_FunctionAllRoots_GetPointState(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns True if the computation has been done successfully.

        """
        return _math.math_FunctionAllRoots_IsDone(self, *args)

    def NbIntervals(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of intervals on which the function is Null. An exception is raised if IsDone returns False.

        """
        return _math.math_FunctionAllRoots_NbIntervals(self, *args)

    def NbPoints(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of points where the function is Null. An exception is raised if IsDone returns False.

        """
        return _math.math_FunctionAllRoots_NbPoints(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionAllRoots

# Register math_FunctionAllRoots in _math:
_math.math_FunctionAllRoots_swigregister(math_FunctionAllRoots)
class math_FunctionRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        Tolerance: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        The Newton-Raphson method is done to find the root of the function F from the initial guess Guess.The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B. The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        Tolerance: float
        A: float
        B: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        The Newton-Raphson method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.

        """
        _math.math_FunctionRoot_swiginit(self, _math.new_math_FunctionRoot(*args))

    def Derivative(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the derivative at the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_FunctionRoot_Derivative(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_FunctionRoot_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_FunctionRoot_IsDone(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done on the computation of the Root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_FunctionRoot_NbIterations(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_FunctionRoot_Root(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the function at the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_FunctionRoot_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoot

# Register math_FunctionRoot in _math:
_math.math_FunctionRoot_swigregister(math_FunctionRoot)
class math_FunctionRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        A: float
        B: float
        NbSample: int
        EpsX: float (optional, default to 0.0)
        EpsF: float (optional, default to 0.0)
        EpsNull: float (optional, default to 0.0)
        K: float (optional, default to 0.0)

        Return
        -------
        None

        Description
        -----------
        Calculates all the real roots of a function F-K within the range A..B. without conditions on A and B A solution X is found when abs(Xi - Xi-1) <= Epsx and abs(F(Xi)-K) <= EpsF. The function is considered as null between A and B if abs(F-K) <= EpsNull within this range.

        """
        _math.math_FunctionRoots_swiginit(self, _math.new_math_FunctionRoots(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object.

        """
        return _math.math_FunctionRoots_Dump(self, *args)

    def IsAllNull(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        returns true if the function is considered as null between A and B. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_FunctionRoots_IsAllNull(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_FunctionRoots_IsDone(self, *args)

    def NbSolutions(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of solutions found. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_FunctionRoots_NbSolutions(self, *args)

    def StateNumber(self, *args):
        r"""

        Parameters
        ----------
        Nieme: int

        Return
        -------
        int

        Description
        -----------
        returns the StateNumber of the Nieme root. Exception RangeError is raised if Nieme is < 1 or Nieme > NbSolutions.

        """
        return _math.math_FunctionRoots_StateNumber(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        Nieme: int

        Return
        -------
        float

        Description
        -----------
        Returns the Nth value of the root of function F. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        """
        return _math.math_FunctionRoots_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoots

# Register math_FunctionRoots in _math:
_math.math_FunctionRoots_swigregister(math_FunctionRoots)
class math_FunctionSample(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float
        N: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_FunctionSample_swiginit(self, _math.new_math_FunctionSample(*args))

    def Bounds(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        A: float
        B: float

        Description
        -----------
        Returns the bounds of parameters.

        """
        return _math.math_FunctionSample_Bounds(self, *args)

    def GetParameter(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the value of parameter of the point of range Index: A + ((Index-1)/(NbPoints-1))*B. An exception is raised if Index<=0 or Index>NbPoints.

        """
        return _math.math_FunctionSample_GetParameter(self, *args)

    def NbPoints(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of sample points.

        """
        return _math.math_FunctionSample_NbPoints(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSample

# Register math_FunctionSample in _math:
_math.math_FunctionSample_swigregister(math_FunctionSample)
class math_FunctionSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the state of the function corresponding to the latestcall of any methods associated with the function. This function is called by each of the algorithms described later which define the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.

        """
        return _math.math_FunctionSet_GetStateNumber(self, *args)

    def NbEquations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of equations of the function.

        """
        return _math.math_FunctionSet_NbEquations(self, *args)

    def NbVariables(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of variables of the function.

        """
        return _math.math_FunctionSet_NbVariables(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        F: math_Vector

        Return
        -------
        bool

        Description
        -----------
        Computes the values <F> of the functions for the variable <X>. returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_FunctionSet_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSet

# Register math_FunctionSet in _math:
_math.math_FunctionSet_swigregister(math_FunctionSet)
class math_FunctionSetRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives
        Tolerance: math_Vector
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called after this constructor.

        """
        _math.math_FunctionSetRoot_swiginit(self, _math.new_math_FunctionSetRoot(*args))

    def Derivative(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the matrix value of the derivative at the root. Exception NotDone is raised if the root was not found.

        Parameters
        ----------
        Der: math_Matrix

        Return
        -------
        None

        Description
        -----------
        outputs the matrix value of the derivative at the root in Der. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the column range of <Der> is not equal to the range of the startingPoint.

        """
        return _math.math_FunctionSetRoot_Derivative(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_FunctionSetRoot_Dump(self, *args)

    def FunctionSetErrors(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the vector value of the error done on the functions at the root. Exception NotDone is raised if the root was not found.

        Parameters
        ----------
        Err: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the vector value of the error done on the functions at the root in Err. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Err is not equal to the range of the StartingPoint.

        """
        return _math.math_FunctionSetRoot_FunctionSetErrors(self, *args)

    def IsDivergent(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _math.math_FunctionSetRoot_IsDivergent(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_FunctionSetRoot_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        &: math_FunctionSetWithDerivatives

        Return
        -------
        bool

        Description
        -----------
        This routine is called at the end of each iteration to check if the solution was found. It can be redefined in a sub-class to implement a specific test to stop the iterations. In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance for all unknowns.

        """
        return _math.math_FunctionSetRoot_IsSolutionReached(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations really done during the computation of the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_FunctionSetRoot_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theStopOnDivergent: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Improves the root of function from the initial guess point. The infinum and supremum may be given to constrain the solution. In this case, the solution is found when: abs(Xi - Xi-1)(j) <= Tolerance(j) for all unknowns.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theInfBound: math_Vector
        theSupBound: math_Vector
        theStopOnDivergent: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Improves the root of function from the initial guess point. The infinum and supremum may be given to constrain the solution. In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance for all unknowns.

        """
        return _math.math_FunctionSetRoot_Perform(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the value of the root of function F. Exception NotDone is raised if the root was not found.

        Parameters
        ----------
        Root: math_Vector

        Return
        -------
        None

        Description
        -----------
        Outputs the root vector in Root. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Root is not equal to the range of the StartingPoint.

        """
        return _math.math_FunctionSetRoot_Root(self, *args)

    def SetTolerance(self, *args):
        r"""

        Parameters
        ----------
        Tolerance: math_Vector

        Return
        -------
        None

        Description
        -----------
        Initializes the tolerance values.

        """
        return _math.math_FunctionSetRoot_SetTolerance(self, *args)

    def StateNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the stateNumber (as returned by F.GetStateNumber()) associated to the root found.

        """
        return _math.math_FunctionSetRoot_StateNumber(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetRoot

# Register math_FunctionSetRoot in _math:
_math.math_FunctionSetRoot_swigregister(math_FunctionSetRoot)
class math_Gauss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float (optional, default to 1.0e-20)
        theProgress: Message_ProgressRange (optional, default to Message_ProgressRange())

        Return
        -------
        None

        Description
        -----------
        Given an input n X n matrix A this constructor performs its LU decomposition with partial pivoting (interchange of rows). This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix A is considered as singular. Exception NotSquare is raised if A is not a square matrix.

        """
        _math.math_Gauss_swiginit(self, _math.new_math_Gauss(*args))

    def Determinant(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        This routine returns the value of the determinant of the previously LU decomposed matrix A. Exception NotDone may be raised if the decomposition of A was not done successfully, zero is returned if the matrix A was considered as singular.

        """
        return _math.math_Gauss_Determinant(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_Gauss_Dump(self, *args)

    def Invert(self, *args):
        r"""

        Parameters
        ----------
        Inv: math_Matrix

        Return
        -------
        None

        Description
        -----------
        This routine outputs Inv the inverse of the previously LU decomposed matrix A. Exception DimensionError is raised if the ranges of B are not equal to the ranges of A.

        """
        return _math.math_Gauss_Invert(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_Gauss_IsDone(self, *args)

    def Solve(self, *args):
        r"""

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Return
        -------
        None

        Description
        -----------
        Given the input Vector B this routine returns the solution X of the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the number of rows of A.

        Parameters
        ----------
        B: math_Vector

        Return
        -------
        None

        Description
        -----------
        Given the input Vector B this routine solves the set of linear equations A . X = B. B is replaced by the vector solution X. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the number of rows of A.

        """
        return _math.math_Gauss_Solve(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Gauss

# Register math_Gauss in _math:
_math.math_Gauss_swigregister(math_Gauss)
class math_GaussLeastSquare(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float (optional, default to 1.0e-20)

        Return
        -------
        None

        Description
        -----------
        Given an input n X m matrix A with n >= m this constructor performs the LU decomposition with partial pivoting (interchange of rows) of the matrix AA = A.Transposed() * A; This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix <A> is considered as singular.

        """
        _math.math_GaussLeastSquare_swiginit(self, _math.new_math_GaussLeastSquare(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_GaussLeastSquare_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.e.

        """
        return _math.math_GaussLeastSquare_IsDone(self, *args)

    def Solve(self, *args):
        r"""

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Return
        -------
        None

        Description
        -----------
        Given the input Vector <B> this routine solves the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B Inv is not equal to the rowrange of A. Exception DimensionError is raised if the range of X Inv is not equal to the colrange of A.

        """
        return _math.math_GaussLeastSquare_Solve(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussLeastSquare

# Register math_GaussLeastSquare in _math:
_math.math_GaussLeastSquare_swigregister(math_GaussLeastSquare)
class math_GaussMultipleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_MultipleVarFunction
        Lower: math_Vector
        Upper: math_Vector
        Order: math_IntegerVector

        Return
        -------
        None

        Description
        -----------
        The Gauss-Legendre integration with Order = points of integration for each unknown, is done on the function F between the bounds Lower and Upper.

        """
        _math.math_GaussMultipleIntegration_swiginit(self, _math.new_math_GaussMultipleIntegration(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_GaussMultipleIntegration_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        returns True if all has been correctly done.

        """
        return _math.math_GaussMultipleIntegration_IsDone(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the integral.

        """
        return _math.math_GaussMultipleIntegration_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussMultipleIntegration

# Register math_GaussMultipleIntegration in _math:
_math.math_GaussMultipleIntegration_swigregister(math_GaussMultipleIntegration)
class math_GaussSetIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionSet
        Lower: math_Vector
        Upper: math_Vector
        Order: math_IntegerVector

        Return
        -------
        None

        Description
        -----------
        The Gauss-Legendre integration with Order = points of integration for each unknown, is done on the function F between the bounds Lower and Upper.

        """
        _math.math_GaussSetIntegration_swiginit(self, _math.new_math_GaussSetIntegration(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_GaussSetIntegration_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        returns True if all has been correctly done.

        """
        return _math.math_GaussSetIntegration_IsDone(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the value of the integral.

        """
        return _math.math_GaussSetIntegration_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSetIntegration

# Register math_GaussSetIntegration in _math:
_math.math_GaussSetIntegration_swigregister(math_GaussSetIntegration)
class math_GaussSingleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        F: math_Function
        Lower: float
        Upper: float
        Order: int

        Return
        -------
        None

        Description
        -----------
        The Gauss-Legendre integration with N = Order points of integration, is done on the function F between the bounds Lower and Upper.

        Parameters
        ----------
        F: math_Function
        Lower: float
        Upper: float
        Order: int
        Tol: float

        Return
        -------
        None

        Description
        -----------
        The Gauss-Legendre integration with N = Order points of integration and given tolerance = Tol is done on the function F between the bounds Lower and Upper.

        """
        _math.math_GaussSingleIntegration_swiginit(self, _math.new_math_GaussSingleIntegration(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_GaussSingleIntegration_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        returns True if all has been correctly done.

        """
        return _math.math_GaussSingleIntegration_IsDone(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the integral.

        """
        return _math.math_GaussSingleIntegration_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSingleIntegration

# Register math_GaussSingleIntegration in _math:
_math.math_GaussSingleIntegration_swigregister(math_GaussSingleIntegration)
class math_GlobOptMin(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowerBorder: math_Vector
        theUpperBorder: math_Vector
        theC: float (optional, default to 9)
        theDiscretizationTol: float (optional, default to 1.0e-2)
        theSameTol: float (optional, default to 1.0e-7)

        Return
        -------
        None

        Description
        -----------
        Constructor. Perform method is not called from it. 
        Parameter theFunc - objective functional. 
        Parameter theLowerBorder - lower corner of the search box. 
        Parameter theUpperBorder - upper corner of the search box. 
        Parameter theC - Lipschitz constant. 
        Parameter theDiscretizationTol - parameter space discretization tolerance. 
        Parameter theSameTol - functional value space indifference tolerance.

        """
        _math.math_GlobOptMin_swiginit(self, _math.new_math_GlobOptMin(*args))

    def GetContinuity(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _math.math_GlobOptMin_GetContinuity(self, *args)

    def GetF(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Get best functional value.

        """
        return _math.math_GlobOptMin_GetF(self, *args)

    def GetFunctionalMinimalValue(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _math.math_GlobOptMin_GetFunctionalMinimalValue(self, *args)

    def GetLipConstState(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _math.math_GlobOptMin_GetLipConstState(self, *args)

    def GetTol(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        theDiscretizationTol: float
        theSameTol: float

        Description
        -----------
        Method to get tolerances. 
        Parameter theDiscretizationTol - parameter space discretization tolerance. 
        Parameter theSameTol - functional value space indifference tolerance.

        """
        return _math.math_GlobOptMin_GetTol(self, *args)

    def NbExtrema(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Return count of global extremas.

        """
        return _math.math_GlobOptMin_NbExtrema(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        isFindSingleSolution: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Parameter isFindSingleSolution - defines whether to find single solution or all solutions.

        """
        return _math.math_GlobOptMin_Perform(self, *args)

    def Points(self, *args):
        r"""

        Parameters
        ----------
        theIndex: int
        theSol: math_Vector

        Return
        -------
        None

        Description
        -----------
        Return solution theIndex, 1 <= theIndex <= NbExtrema.

        """
        return _math.math_GlobOptMin_Points(self, *args)

    def SetContinuity(self, *args):
        r"""

        Parameters
        ----------
        theCont: int

        Return
        -------
        None

        Description
        -----------
        Set / Get continuity of local borders splits (0 ~ C0, 1 ~ C1, 2 ~ C2).

        """
        return _math.math_GlobOptMin_SetContinuity(self, *args)

    def SetFunctionalMinimalValue(self, *args):
        r"""

        Parameters
        ----------
        theMinimalValue: float

        Return
        -------
        None

        Description
        -----------
        Set / Get functional minimal value.

        """
        return _math.math_GlobOptMin_SetFunctionalMinimalValue(self, *args)

    def SetGlobalParams(self, *args):
        r"""

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowerBorder: math_Vector
        theUpperBorder: math_Vector
        theC: float (optional, default to 9)
        theDiscretizationTol: float (optional, default to 1.0e-2)
        theSameTol: float (optional, default to 1.0e-7)

        Return
        -------
        None

        Description
        -----------
        Parameter theFunc - objective functional. 
        Parameter theLowerBorder - lower corner of the search box. 
        Parameter theUpperBorder - upper corner of the search box. 
        Parameter theC - Lipschitz constant. 
        Parameter theDiscretizationTol - parameter space discretization tolerance. 
        Parameter theSameTol - functional value space indifference tolerance.

        """
        return _math.math_GlobOptMin_SetGlobalParams(self, *args)

    def SetLipConstState(self, *args):
        r"""

        Parameters
        ----------
        theFlag: bool

        Return
        -------
        None

        Description
        -----------
        Set / Get Lipchitz constant modification state. True means that the constant is locked and unlocked otherwise.

        """
        return _math.math_GlobOptMin_SetLipConstState(self, *args)

    def SetLocalParams(self, *args):
        r"""

        Parameters
        ----------
        theLocalA: math_Vector
        theLocalB: math_Vector

        Return
        -------
        None

        Description
        -----------
        Method to reduce bounding box. Perform will use this box. 
        Parameter theLocalA - lower corner of the local box. 
        Parameter theLocalB - upper corner of the local box.

        """
        return _math.math_GlobOptMin_SetLocalParams(self, *args)

    def SetTol(self, *args):
        r"""

        Parameters
        ----------
        theDiscretizationTol: float
        theSameTol: float

        Return
        -------
        None

        Description
        -----------
        Method to set tolerances. 
        Parameter theDiscretizationTol - parameter space discretization tolerance. 
        Parameter theSameTol - functional value space indifference tolerance.

        """
        return _math.math_GlobOptMin_SetTol(self, *args)

    def isDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Return computation state of the algorithm.

        """
        return _math.math_GlobOptMin_isDone(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GlobOptMin

# Register math_GlobOptMin in _math:
_math.math_GlobOptMin_swigregister(math_GlobOptMin)
class math_Householder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix
        B: math_Matrix
        EPS: float (optional, default to 1.0e-20)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.

        Parameters
        ----------
        A: math_Matrix
        B: math_Matrix
        lowerArow: int
        upperArow: int
        lowerAcol: int
        upperAcol: int
        EPS: float (optional, default to 1.0e-20)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.

        Parameters
        ----------
        A: math_Matrix
        B: math_Vector
        EPS: float (optional, default to 1.0e-20)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix A with n>= m, given an input vector B this constructor performs the least square resolution of the set of linear equations A.X = B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the length of B is different from the A row number.

        """
        _math.math_Householder_swiginit(self, _math.new_math_Householder(*args))

    def AllValues(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the matrix sol of all the solutions of the system A.X = B. Exception NotDone is raised is the resolution has not be done.

        """
        return _math.math_Householder_AllValues(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_Householder_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_Householder_IsDone(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        sol: math_Vector
        Index: int (optional, default to 1)

        Return
        -------
        None

        Description
        -----------
        Given the integer Index, this routine returns the corresponding least square solution sol. Exception NotDone is raised if the resolution has not be done. Exception OutOfRange is raised if Index <=0 or Index is more than the number of columns of B.

        """
        return _math.math_Householder_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Householder

# Register math_Householder in _math:
_math.math_Householder_swigregister(math_Householder)
class math_Jacobi(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Given a Real n X n matrix A, this constructor computes all its eigenvalues and eigenvectors using the Jacobi method. The exception NotSquare is raised if the matrix is not square. No verification that the matrix A is really symmetric is done.

        """
        _math.math_Jacobi_swiginit(self, _math.new_math_Jacobi(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_Jacobi_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_Jacobi_IsDone(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        Num: int

        Return
        -------
        float

        Description
        -----------
        returns the eigenvalue number Num. Eigenvalues are in the range (1..n). Exception NotDone is raised if calculation is not done successfully.

        """
        return _math.math_Jacobi_Value(self, *args)

    def Values(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the eigenvalues vector. Exception NotDone is raised if calculation is not done successfully.

        """
        return _math.math_Jacobi_Values(self, *args)

    def Vector(self, *args):
        r"""

        Parameters
        ----------
        Num: int
        V: math_Vector

        Return
        -------
        None

        Description
        -----------
        Returns the eigenvector V of number Num. Eigenvectors are in the range (1..n). Exception NotDone is raised if calculation is not done successfully.

        """
        return _math.math_Jacobi_Vector(self, *args)

    def Vectors(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        returns the eigenvectors matrix. Exception NotDone is raised if calculation is not done successfully.

        """
        return _math.math_Jacobi_Vectors(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Jacobi

# Register math_Jacobi in _math:
_math.math_Jacobi_swigregister(math_Jacobi)
class math_KronrodSingleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        An empty constructor.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int

        Return
        -------
        None

        Description
        -----------
        Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int
        theTolerance: float
        theMaxNbIter: int

        Return
        -------
        None

        Description
        -----------
        Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the tolerance value and the maximal number of iterations as parameters.

        """
        _math.math_KronrodSingleIntegration_swiginit(self, _math.new_math_KronrodSingleIntegration(*args))

    def AbsolutError(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the relative error reached.

        """
        return _math.math_KronrodSingleIntegration_AbsolutError(self, *args)

    def ErrorReached(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the relative error reached.

        """
        return _math.math_KronrodSingleIntegration_ErrorReached(self, *args)

    @staticmethod
    def GKRule(*args):
        r"""

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theGaussP: math_Vector
        theGaussW: math_Vector
        theKronrodP: math_Vector
        theKronrodW: math_Vector

        Return
        -------
        theValue: float
        theError: float

        Description
        -----------
        No available documentation.

        """
        return _math.math_KronrodSingleIntegration_GKRule(*args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns Standard_True if computation is performed successfully.

        """
        return _math.math_KronrodSingleIntegration_IsDone(self, *args)

    def NbIterReached(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations that were made to compute result.

        """
        return _math.math_KronrodSingleIntegration_NbIterReached(self, *args)

    def OrderReached(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of Kronrod points for which the result is computed.

        """
        return _math.math_KronrodSingleIntegration_OrderReached(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int

        Return
        -------
        None

        Description
        -----------
        Computation of the integral. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the relative tolerance value and the maximal number of iterations as parameters. theNbPnts should be odd and greater then or equal to 3.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int
        theTolerance: float
        theMaxNbIter: int

        Return
        -------
        None

        Description
        -----------
        Computation of the integral. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the relative tolerance value and the maximal number of iterations as parameters. theNbPnts should be odd and greater then or equal to 3. Note that theTolerance is relative, i.e. the criterion of solution reaching is: Abs(Kronrod - Gauss)/Abs(Kronrod) < theTolerance. theTolerance should be positive.

        """
        return _math.math_KronrodSingleIntegration_Perform(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the integral.

        """
        return _math.math_KronrodSingleIntegration_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_KronrodSingleIntegration

# Register math_KronrodSingleIntegration in _math:
_math.math_KronrodSingleIntegration_swigregister(math_KronrodSingleIntegration)
class math_Matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Return
        -------
        None

        Description
        -----------
        Constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] For the constructed matrix: - LowerRow and UpperRow are the indexes of the lower and upper bounds of a row, and - LowerCol and UpperCol are the indexes of the lower and upper bounds of a column.

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int
        InitialValue: float

        Return
        -------
        None

        Description
        -----------
        constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] whose values are all initialized with the value InitialValue.

        Parameters
        ----------
        Tab: Standard_Address
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Return
        -------
        None

        Description
        -----------
        constructs a matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] Sharing data with a 'C array' pointed by Tab.

        Parameters
        ----------
        Other: math_Matrix

        Return
        -------
        None

        Description
        -----------
        constructs a matrix for copy in initialization. An exception is raised if the matrixes have not the same dimensions.

        """
        _math.math_Matrix_swiginit(self, _math.new_math_Matrix(*args))

    def Add(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        adds the matrix <Right> to a matrix. An exception is raised if the dimensions are different. Warning In order to save time when copying matrices, it is preferable to use operator += or the function Add whenever possible.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        sets a matrix to the addition of <Left> and <Right>. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Add(self, *args)

    def Added(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        adds the matrix <Right> to a matrix. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Added(self, *args)

    def Col(self, *args):
        r"""

        Parameters
        ----------
        Col: int

        Return
        -------
        math_VectorBase<>

        Description
        -----------
        Returns the column of index <Col> of a matrix.

        """
        return _math.math_Matrix_Col(self, *args)

    def ColNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of rows of this matrix. Note that for a matrix A you always have the following relations: - A.RowNumber() = A.UpperRow() - A.LowerRow() + 1 - A.ColNumber() = A.UpperCol() - A.LowerCol() + 1 - the length of a row of A is equal to the number of columns of A, - the length of a column of A is equal to the number of rows of A.returns the row range of a matrix.

        """
        return _math.math_Matrix_ColNumber(self, *args)

    def Determinant(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Computes the determinant of a matrix. An exception is raised if the matrix is not a square matrix.

        """
        return _math.math_Matrix_Determinant(self, *args)

    def Divide(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        None

        Description
        -----------
        divides all the elements of a matrix by the value <Right>. An exception is raised if <Right> = 0.

        """
        return _math.math_Matrix_Divide(self, *args)

    def Divided(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        math_Matrix

        Description
        -----------
        divides all the elements of a matrix by the value <Right>. An exception is raised if <Right> = 0.

        """
        return _math.math_Matrix_Divided(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_Matrix_Dump(self, *args)

    def Init(self, *args):
        r"""

        Parameters
        ----------
        InitialValue: float

        Return
        -------
        None

        Description
        -----------
        Initialize all the elements of a matrix to InitialValue.

        """
        return _math.math_Matrix_Init(self, *args)

    def Initialized(self, *args):
        r"""

        Parameters
        ----------
        Other: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        Matrixes are copied through assignment. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Initialized(self, *args)

    def Inverse(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the inverse of a matrix. Exception NotSquare is raised if the matrix is not square. Exception SingularMatrix is raised if the matrix is singular.

        """
        return _math.math_Matrix_Inverse(self, *args)

    def Invert(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Inverts a matrix using Gauss algorithm. Exception NotSquare is raised if the matrix is not square. Exception SingularMatrix is raised if the matrix is singular.

        """
        return _math.math_Matrix_Invert(self, *args)

    def LowerCol(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the value of the Lower index of the column range of a matrix.

        """
        return _math.math_Matrix_LowerCol(self, *args)

    def LowerRow(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the value of the Lower index of the row range of a matrix.

        """
        return _math.math_Matrix_LowerRow(self, *args)

    def Multiplied(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        math_Matrix

        Description
        -----------
        multiplies all the elements of a matrix by the value <Right>.

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the product of 2 matrices. An exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_VectorBase<>

        Return
        -------
        math_VectorBase<>

        Description
        -----------
        Returns the product of a matrix by a vector. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Multiplied(self, *args)

    def Multiply(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        None

        Description
        -----------
        Sets this matrix to the product of the matrix Left, and the matrix Right. Example math_Matrix A (1, 3, 1, 3); math_Matrix B (1, 3, 1, 3); // A = ... , B = ... math_Matrix C (1, 3, 1, 3); C.Multiply(A, B); Exceptions Standard_DimensionError if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix Left, or the number of rows of matrix TLeft is not equal to the number of rows of matrix Right, or - the number of rows of matrix Left, or the number of columns of matrix TLeft is not equal to the number of rows of this matrix, or - the number of columns of matrix Right is not equal to the number of columns of this matrix.

        Parameters
        ----------
        Left: math_VectorBase<>
        Right: math_VectorBase<>

        Return
        -------
        None

        Description
        -----------
        Computes a matrix as the product of 2 vectors. An exception is raised if the dimensions are different. <self> = <Left> * <Right>.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Computes a matrix as the product of 2 matrixes. An exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Returns the product of 2 matrices. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Multiply(self, *args)

    def Opposite(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the opposite of a matrix. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Opposite(self, *args)

    def Row(self, *args):
        r"""

        Parameters
        ----------
        Row: int

        Return
        -------
        math_VectorBase<>

        Description
        -----------
        Returns the row of index Row of a matrix.

        """
        return _math.math_Matrix_Row(self, *args)

    def RowNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of rows of this matrix. Note that for a matrix A you always have the following relations: - A.RowNumber() = A.UpperRow() - A.LowerRow() + 1 - A.ColNumber() = A.UpperCol() - A.LowerCol() + 1 - the length of a row of A is equal to the number of columns of A, - the length of a column of A is equal to the number of rows of A.returns the row range of a matrix.

        """
        return _math.math_Matrix_RowNumber(self, *args)

    def Set(self, *args):
        r"""

        Parameters
        ----------
        I1: int
        I2: int
        J1: int
        J2: int
        M: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Sets the values of this matrix, - from index I1 to index I2 on the row dimension, and - from index J1 to index J2 on the column dimension, to those of matrix M. Exceptions Standard_DimensionError if: - I1 is less than the index of the lower row bound of this matrix, or - I2 is greater than the index of the upper row bound of this matrix, or - J1 is less than the index of the lower column bound of this matrix, or - J2 is greater than the index of the upper column bound of this matrix, or - I2 - I1 + 1 is not equal to the number of rows of matrix M, or - J2 - J1 + 1 is not equal to the number of columns of matrix M.

        """
        return _math.math_Matrix_Set(self, *args)

    def SetCol(self, *args):
        r"""

        Parameters
        ----------
        Col: int
        V: math_VectorBase<>

        Return
        -------
        None

        Description
        -----------
        Sets the column of index Col of a matrix to the vector <V>. An exception is raised if the dimensions are different. An exception is raises if <Col> is inferior to the lower column of the matrix or <Col> is superior to the upper column.

        """
        return _math.math_Matrix_SetCol(self, *args)

    def SetDiag(self, *args):
        r"""

        Parameters
        ----------
        Value: float

        Return
        -------
        None

        Description
        -----------
        Sets the diagonal of a matrix to the value <Value>. An exception is raised if the matrix is not square.

        """
        return _math.math_Matrix_SetDiag(self, *args)

    def SetRow(self, *args):
        r"""

        Parameters
        ----------
        Row: int
        V: math_VectorBase<>

        Return
        -------
        None

        Description
        -----------
        Sets the row of index Row of a matrix to the vector <V>. An exception is raised if the dimensions are different. An exception is raises if <Row> is inferior to the lower row of the matrix or <Row> is superior to the upper row.

        """
        return _math.math_Matrix_SetRow(self, *args)

    def Subtract(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Subtracts the matrix <Right> from <self>. An exception is raised if the dimensions are different. Warning In order to avoid time-consuming copying of matrices, it is preferable to use operator -= or the function Subtract whenever possible.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Sets a matrix to the Subtraction of the matrix <Right> from the matrix <Left>. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Subtract(self, *args)

    def Subtracted(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the result of the subtraction of <Right> from <self>. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_Subtracted(self, *args)

    def SwapCol(self, *args):
        r"""

        Parameters
        ----------
        Col1: int
        Col2: int

        Return
        -------
        None

        Description
        -----------
        Swaps the columns of index <Col1> and <Col2>. An exception is raised if <Col1> or <Col2> is out of range.

        """
        return _math.math_Matrix_SwapCol(self, *args)

    def SwapRow(self, *args):
        r"""

        Parameters
        ----------
        Row1: int
        Row2: int

        Return
        -------
        None

        Description
        -----------
        Swaps the rows of index Row1 and Row2. An exception is raised if <Row1> or <Row2> is out of range.

        """
        return _math.math_Matrix_SwapRow(self, *args)

    def TMultiplied(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        math_Matrix

        Description
        -----------
        Sets this matrix to the product of the transposed matrix TLeft, and the matrix Right. Example math_Matrix A (1, 3, 1, 3); math_Matrix B (1, 3, 1, 3); // A = ... , B = ... math_Matrix C (1, 3, 1, 3); C.Multiply(A, B); Exceptions Standard_DimensionError if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix Left, or the number of rows of matrix TLeft is not equal to the number of rows of matrix Right, or - the number of rows of matrix Left, or the number of columns of matrix TLeft is not equal to the number of rows of this matrix, or - the number of columns of matrix Right is not equal to the number of columns of this matrix.

        """
        return _math.math_Matrix_TMultiplied(self, *args)

    def TMultiply(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the product of the transpose of a matrix with the matrix <Right>. An exception is raised if the dimensions are different.

        Parameters
        ----------
        TLeft: math_Matrix
        Right: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Computes a matrix to the product of the transpose of the matrix <TLeft> with the matrix <Right>. An exception is raised if the dimensions are different.

        """
        return _math.math_Matrix_TMultiply(self, *args)

    def Transpose(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Transposes a given matrix. An exception is raised if the matrix is not a square matrix.

        """
        return _math.math_Matrix_Transpose(self, *args)

    def Transposed(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Teturns the transposed of a matrix. An exception is raised if the matrix is not a square matrix.

        """
        return _math.math_Matrix_Transposed(self, *args)

    def UpperCol(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the value of the upper index of the column range of a matrix.

        """
        return _math.math_Matrix_UpperCol(self, *args)

    def UpperRow(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the Upper index of the row range of a matrix.

        """
        return _math.math_Matrix_UpperRow(self, *args)

    def GetValue(self, Row, Col):
        r"""GetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real"""
        return _math.math_Matrix_GetValue(self, Row, Col)

    def SetValue(self, Row, Col, value):
        r"""SetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real value)"""
        return _math.math_Matrix_SetValue(self, Row, Col, value)

    def __mul__(self, *args):
        r"""

        Parameters
        ----------
        Right: float

        Return
        -------
        math_Matrix

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        Right: math_VectorBase<>

        Return
        -------
        math_VectorBase<>

        Description
        -----------
        No available documentation.

        """
        return _math.math_Matrix___mul__(self, *args)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args):
        r"""
        __imul_wrapper__(math_Matrix self, Standard_Real const other)
        __imul_wrapper__(math_Matrix self, math_Matrix other)
        """
        return _math.math_Matrix___imul_wrapper__(self, *args)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        No available documentation.

        """
        return _math.math_Matrix___add__(self, *args)

    def __iadd_wrapper__(self, other):
        r"""__iadd_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___iadd_wrapper__(self, other)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args):
        r"""

        Parameters
        ----------
        Right: math_Matrix

        Return
        -------
        math_Matrix

        Description
        -----------
        No available documentation.

        """
        return _math.math_Matrix___sub__(self, *args)

    def __neg__(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        No available documentation.

        """
        return _math.math_Matrix___neg__(self, *args)

    def __isub_wrapper__(self, other):
        r"""__isub_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___isub_wrapper__(self, other)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Matrix___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other):
        r"""__itruediv_wrapper__(math_Matrix self, Standard_Real const other)"""
        return _math.math_Matrix___itruediv_wrapper__(self, other)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Matrix

# Register math_Matrix in _math:
_math.math_Matrix_swigregister(math_Matrix)
class math_MultipleVarFunction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        return the state of the function corresponding to the latestt call of any methods associated to the function. This function is called by each of the algorithms described later which define the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.

        """
        return _math.math_MultipleVarFunction_GetStateNumber(self, *args)

    def NbVariables(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of variables of the function.

        """
        return _math.math_MultipleVarFunction_NbVariables(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector

        Return
        -------
        F: float

        Description
        -----------
        Computes the values of the Functions <F> for the variable <X>. returns True if the computation was done successfully, otherwise false.

        """
        return _math.math_MultipleVarFunction_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunction

# Register math_MultipleVarFunction in _math:
_math.math_MultipleVarFunction_swigregister(math_MultipleVarFunction)
class math_NewtonFunctionRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        EpsX: float
        EpsF: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        The Newton method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. The solution is found when: abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        EpsX: float
        EpsF: float
        A: float
        B: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        The Newton method is done to find the root of the function F from the initial guess Guess. The solution must be inside the interval [A, B]. The tolerance required on the root is given by Tolerance. The solution is found when: abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.

        Parameters
        ----------
        A: float
        B: float
        EpsX: float
        EpsF: float
        NbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        is used in a sub-class to initialize correctly all the fields of this class.

        """
        _math.math_NewtonFunctionRoot_swiginit(self, _math.new_math_NewtonFunctionRoot(*args))

    def Derivative(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the derivative at the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_NewtonFunctionRoot_Derivative(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_NewtonFunctionRoot_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_NewtonFunctionRoot_IsDone(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations really done on the computation of the Root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_NewtonFunctionRoot_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float

        Return
        -------
        None

        Description
        -----------
        is used internally by the constructors.

        """
        return _math.math_NewtonFunctionRoot_Perform(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the root of function <F>. Exception NotDone is raised if the root was not found.

        """
        return _math.math_NewtonFunctionRoot_Root(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the function at the root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_NewtonFunctionRoot_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionRoot

# Register math_NewtonFunctionRoot in _math:
_math.math_NewtonFunctionRoot_swigregister(math_NewtonFunctionRoot)
class math_NewtonFunctionSetRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theXTolerance: math_Vector
        theFTolerance: float
        tehNbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        Initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theFTolerance: float
        theNbIterations: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        This constructor should be used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called before performing the algorithm.

        """
        _math.math_NewtonFunctionSetRoot_swiginit(self, _math.new_math_NewtonFunctionSetRoot(*args))

    def Derivative(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        Returns the matrix value of the derivative at the root. Exception NotDone is raised if the root was not found.

        Parameters
        ----------
        Der: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Outputs the matrix value of the derivative at the root in Der. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Der is not equal to the range of the StartingPoint.

        """
        return _math.math_NewtonFunctionSetRoot_Derivative(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_NewtonFunctionSetRoot_Dump(self, *args)

    def FunctionSetErrors(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the vector value of the error done on the functions at the root. Exception NotDone is raised if the root was not found.

        Parameters
        ----------
        Err: math_Vector

        Return
        -------
        None

        Description
        -----------
        Outputs the vector value of the error done on the functions at the root in Err. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Err is not equal to the range of the StartingPoint.

        """
        return _math.math_NewtonFunctionSetRoot_FunctionSetErrors(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_NewtonFunctionSetRoot_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives

        Return
        -------
        bool

        Description
        -----------
        This method is called at the end of each iteration to check if the solution is found. Vectors DeltaX, Fvalues and Jacobian Matrix are consistent with the possible solution Vector Sol and can be inspected to decide whether the solution is reached or not.

        """
        return _math.math_NewtonFunctionSetRoot_IsSolutionReached(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations really done during the computation of the Root. Exception NotDone is raised if the root was not found.

        """
        return _math.math_NewtonFunctionSetRoot_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector

        Return
        -------
        None

        Description
        -----------
        The Newton method is done to improve the root of the function from the initial guess point. The solution is found when: abs(Xj - Xj-1)(i) <= XTol(i) and abs(Fi) <= FTol for all i;.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theInfBound: math_Vector
        theSupBound: math_Vector

        Return
        -------
        None

        Description
        -----------
        The Newton method is done to improve the root of the function from the initial guess point. Bounds may be given, to constrain the solution. The solution is found when: abs(Xj - Xj-1)(i) <= XTol(i) and abs(Fi) <= FTol for all i;.

        """
        return _math.math_NewtonFunctionSetRoot_Perform(self, *args)

    def Root(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the value of the root of function F. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).

        Parameters
        ----------
        Root: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the root vector in Root. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Root is not equal to the range of the StartingPoint.

        """
        return _math.math_NewtonFunctionSetRoot_Root(self, *args)

    def SetTolerance(self, *args):
        r"""

        Parameters
        ----------
        XTol: math_Vector

        Return
        -------
        None

        Description
        -----------
        Initializes the tolerance values for the unknowns.

        """
        return _math.math_NewtonFunctionSetRoot_SetTolerance(self, *args)

    __repr__ = _dumps_object

    @methodnotwrapped
    def StateNumber(self):
    	pass

    __swig_destroy__ = _math.delete_math_NewtonFunctionSetRoot

# Register math_NewtonFunctionSetRoot in _math:
_math.math_NewtonFunctionSetRoot_swigregister(math_NewtonFunctionSetRoot)
class math_NewtonMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithHessian
        theTolerance: float (optional, default to Precision::Confusion())
        theNbIterations: int (optional, default to 40)
        theConvexity: float (optional, default to 1.0e-6)
        theWithSingularity: bool (optional, default to Standard_True)

        Return
        -------
        None

        Description
        -----------
        The tolerance required on the solution is given by Tolerance. Iteration are stopped if (!WithSingularity) and H(F(Xi)) is not definite positive (if the smaller eigenvalue of H < Convexity) or IsConverged() returns True for 2 successives Iterations. Warning: This constructor does not perform computation.

        """
        _math.math_NewtonMinimum_swiginit(self, _math.new_math_NewtonMinimum(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints on the stream o information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_NewtonMinimum_Dump(self, *args)

    def GetStatus(self, *args):
        r"""
        Return
        -------
        math_Status

        Description
        -----------
        Returns the Status of computation. The exception NotDone is raised if an error has occurred.

        """
        return _math.math_NewtonMinimum_GetStatus(self, *args)

    def Gradient(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the gradient vector at the minimum. Exception NotDone is raised if an error has occurred. The minimum was not found.

        Parameters
        ----------
        Grad: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.

        """
        return _math.math_NewtonMinimum_Gradient(self, *args)

    def IsConverged(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        This method is called at the end of each iteration to check the convergence: || Xi+1 - Xi || < Tolerance or || F(Xi+1) - F(Xi)|| < Tolerance * || F(Xi) || It can be redefined in a sub-class to implement a specific test.

        """
        return _math.math_NewtonMinimum_IsConverged(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Tests if an error has occurred.

        """
        return _math.math_NewtonMinimum_IsDone(self, *args)

    def Location(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the location vector of the minimum. Exception NotDone is raised if an error has occurred.

        Parameters
        ----------
        Loc: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the location vector of the minimum in Loc. Exception NotDone is raised if an error has occurred. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.

        """
        return _math.math_NewtonMinimum_Location(self, *args)

    def Minimum(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        returns the value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_NewtonMinimum_Minimum(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done in the calculation of the minimum. The exception NotDone is raised if an error has occurred.

        """
        return _math.math_NewtonMinimum_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithHessian
        theStartingPoint: math_Vector

        Return
        -------
        None

        Description
        -----------
        Search the solution.

        """
        return _math.math_NewtonMinimum_Perform(self, *args)

    def SetBoundary(self, *args):
        r"""

        Parameters
        ----------
        theLeftBorder: math_Vector
        theRightBorder: math_Vector

        Return
        -------
        None

        Description
        -----------
        Set boundaries.

        """
        return _math.math_NewtonMinimum_SetBoundary(self, *args)

    __repr__ = _dumps_object

    @methodnotwrapped
    def IsConvex(self):
    	pass

    __swig_destroy__ = _math.delete_math_NewtonMinimum

# Register math_NewtonMinimum in _math:
_math.math_NewtonMinimum_swigregister(math_NewtonMinimum)
class math_PSO(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowBorder: math_Vector
        theUppBorder: math_Vector
        theSteps: math_Vector
        theNbParticles: int (optional, default to 32)
        theNbIter: int (optional, default to 100)

        Return
        -------
        None

        Description
        -----------
        /** * Constructor. * * 
        Parameter theFunc defines the objective function. It should exist during all lifetime of class instance. * 
        Parameter theLowBorder defines lower border of search space. * 
        Parameter theUppBorder defines upper border of search space. * 
        Parameter theSteps defines steps of regular grid, used for particle generation. This parameter used to define stop condition (TerminalVelocity). * 
        Parameter theNbParticles defines number of particles. * 
        Parameter theNbIter defines maximum number of iterations. */.

        """
        _math.math_PSO_swiginit(self, _math.new_math_PSO(*args))

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theSteps: math_Vector
        theOutPnt: math_Vector
        theNbIter: int (optional, default to 100)

        Return
        -------
        theValue: float

        Description
        -----------
        Perform computations, particles array is constructed inside of this function.

        Parameters
        ----------
        theParticles: math_PSOParticlesPool
        theNbParticles: int
        theOutPnt: math_Vector
        theNbIter: int (optional, default to 100)

        Return
        -------
        theValue: float

        Description
        -----------
        Perform computations with given particles array.

        """
        return _math.math_PSO_Perform(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSO

# Register math_PSO in _math:
_math.math_PSO_swigregister(math_PSO)
class math_PSOParticlesPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theParticlesCount: int
        theDimensionCount: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_PSOParticlesPool_swiginit(self, _math.new_math_PSOParticlesPool(*args))

    def GetBestParticle(self, *args):
        r"""
        Return
        -------
        PSO_Particle *

        Description
        -----------
        No available documentation.

        """
        return _math.math_PSOParticlesPool_GetBestParticle(self, *args)

    def GetParticle(self, *args):
        r"""

        Parameters
        ----------
        theIdx: int

        Return
        -------
        PSO_Particle *

        Description
        -----------
        No available documentation.

        """
        return _math.math_PSOParticlesPool_GetParticle(self, *args)

    def GetWorstParticle(self, *args):
        r"""
        Return
        -------
        PSO_Particle *

        Description
        -----------
        No available documentation.

        """
        return _math.math_PSOParticlesPool_GetWorstParticle(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSOParticlesPool

# Register math_PSOParticlesPool in _math:
_math.math_PSOParticlesPool_swigregister(math_PSOParticlesPool)
class math_Powell(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunction
        theTolerance: float
        theNbIterations: int (optional, default to 200)
        theZEPS: float (optional, default to 1.0e-12)

        Return
        -------
        None

        Description
        -----------
        Constructor. Initialize new entity.

        """
        _math.math_Powell_swiginit(self, _math.new_math_Powell(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_Powell_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_Powell_IsDone(self, *args)

    def IsSolutionReached(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunction

        Return
        -------
        bool

        Description
        -----------
        Solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS. The maximum number of iterations allowed is given by NbIterations.

        """
        return _math.math_Powell_IsSolutionReached(self, *args)

    def Location(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.

        Parameters
        ----------
        Loc: math_Vector

        Return
        -------
        None

        Description
        -----------
        outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.

        """
        return _math.math_Powell_Location(self, *args)

    def Minimum(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the value of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_Powell_Minimum(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.

        """
        return _math.math_Powell_NbIterations(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theFunction: math_MultipleVarFunction
        theStartingPoint: math_Vector
        theStartingDirections: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Computes Powell minimization on the function F given theStartingPoint, and an initial matrix theStartingDirection whose columns contain the initial set of directions. The solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) =< Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).

        """
        return _math.math_Powell_Perform(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Powell

# Register math_Powell in _math:
_math.math_Powell_swigregister(math_Powell)
class math_SVD(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: math_Matrix

        Return
        -------
        None

        Description
        -----------
        Given as input an n X m matrix A with n < m, n = m or n > m this constructor performs the Singular Value Decomposition.

        """
        _math.math_SVD_swiginit(self, _math.new_math_SVD(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object. Is used to redefine the operator <<.

        """
        return _math.math_SVD_Dump(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_SVD_IsDone(self, *args)

    def PseudoInverse(self, *args):
        r"""

        Parameters
        ----------
        Inv: math_Matrix
        Eps: float (optional, default to 1.0e-6)

        Return
        -------
        None

        Description
        -----------
        Computes the inverse Inv of matrix A such as A * Inverse = Identity. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false). Standard_DimensionError if the ranges of Inv are compatible with the ranges of A.

        """
        return _math.math_SVD_PseudoInverse(self, *args)

    def Solve(self, *args):
        r"""

        Parameters
        ----------
        B: math_Vector
        X: math_Vector
        Eps: float (optional, default to 1.0e-6)

        Return
        -------
        None

        Description
        -----------
        Given the input Vector B this routine solves the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the rowrange of A. Exception DimensionError is raised if the range of X is not equal to the colrange of A.

        """
        return _math.math_SVD_Solve(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_SVD

# Register math_SVD in _math:
_math.math_SVD_swigregister(math_SVD)
class math_TrigonometricFunctionRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float
        InfBound: float
        SupBound: float

        Return
        -------
        None

        Description
        -----------
        Given coefficients a, b, c, d , e, this constructor performs the resolution of the equation above. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.

        Parameters
        ----------
        D: float
        E: float
        InfBound: float
        SupBound: float

        Return
        -------
        None

        Description
        -----------
        Given the two coefficients d and e, it performs the resolution of d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.

        Parameters
        ----------
        C: float
        D: float
        E: float
        InfBound: float
        SupBound: float

        Return
        -------
        None

        Description
        -----------
        Given the three coefficients c, d and e, it performs the resolution of c*Cos(x) + d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.

        """
        _math.math_TrigonometricFunctionRoots_swiginit(self, _math.new_math_TrigonometricFunctionRoots(*args))

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_TrigonometricFunctionRoots_Dump(self, *args)

    def InfiniteRoots(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if there is an infinity of roots, otherwise returns false.

        """
        return _math.math_TrigonometricFunctionRoots_InfiniteRoots(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_TrigonometricFunctionRoots_IsDone(self, *args)

    def NbSolutions(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of solutions found. An exception is raised if NotDone. An exception is raised if there is an infinity of solutions.

        """
        return _math.math_TrigonometricFunctionRoots_NbSolutions(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the solution of range Index. An exception is raised if NotDone. An exception is raised if Index>NbSolutions. An exception is raised if there is an infinity of solutions.

        """
        return _math.math_TrigonometricFunctionRoots_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricFunctionRoots

# Register math_TrigonometricFunctionRoots in _math:
_math.math_TrigonometricFunctionRoots_swigregister(math_TrigonometricFunctionRoots)
class math_Uzawa(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Cont: math_Matrix
        Secont: math_Vector
        StartingPoint: math_Vector
        EpsLix: float (optional, default to 1.0e-06)
        EpsLic: float (optional, default to 1.0e-06)
        NbIterations: int (optional, default to 500)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (only = equations) with a minimization of Norme(X-X0). The maximum iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. Exception ConstructionError is raised if the line number of Cont is different from the length of Secont.

        Parameters
        ----------
        Cont: math_Matrix
        Secont: math_Vector
        StartingPoint: math_Vector
        Nci: int
        Nce: int
        EpsLix: float (optional, default to 1.0e-06)
        EpsLic: float (optional, default to 1.0e-06)
        NbIterations: int (optional, default to 500)

        Return
        -------
        None

        Description
        -----------
        Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (the Nce first equations are equal equations and the Nci last equations are inequalities <) with a minimization of Norme(X-X0). The maximum iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. There are no conditions on Nce and Nci. Exception ConstructionError is raised if the line number of Cont is different from the length of Secont and from Nce + Nci.

        """
        _math.math_Uzawa_swiginit(self, _math.new_math_Uzawa(*args))

    def Duale(self, *args):
        r"""

        Parameters
        ----------
        V: math_Vector

        Return
        -------
        None

        Description
        -----------
        returns the duale variables V of the systeme.

        """
        return _math.math_Uzawa_Duale(self, *args)

    def Dump(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        o: Standard_OStream

        Description
        -----------
        Prints information on the current state of the object.

        """
        return _math.math_Uzawa_Dump(self, *args)

    def Error(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the difference between X solution and the StartingPoint. An exception is raised if NotDone.

        """
        return _math.math_Uzawa_Error(self, *args)

    def InitialError(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the initial error Cont*StartingPoint-Secont. An exception is raised if NotDone.

        """
        return _math.math_Uzawa_InitialError(self, *args)

    def InverseCont(self, *args):
        r"""
        Return
        -------
        math_Matrix

        Description
        -----------
        returns the inverse matrix of (C * Transposed(C)). This result is needed for the computation of the gradient when approximating a curve.

        """
        return _math.math_Uzawa_InverseCont(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the computations are successful, otherwise returns false.

        """
        return _math.math_Uzawa_IsDone(self, *args)

    def NbIterations(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        returns the number of iterations really done. An exception is raised if NotDone.

        """
        return _math.math_Uzawa_NbIterations(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        math_Vector

        Description
        -----------
        Returns the vector solution of the system above. An exception is raised if NotDone.

        """
        return _math.math_Uzawa_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Uzawa

# Register math_Uzawa in _math:
_math.math_Uzawa_swigregister(math_Uzawa)
class math_ValueAndWeight(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        theValue: float
        theWeight: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_ValueAndWeight_swiginit(self, _math.new_math_ValueAndWeight(*args))

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _math.math_ValueAndWeight_Value(self, *args)

    def Weight(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _math.math_ValueAndWeight_Weight(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ValueAndWeight

# Register math_ValueAndWeight in _math:
_math.math_ValueAndWeight_swigregister(math_ValueAndWeight)
class math_FunctionSetWithDerivatives(math_FunctionSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivatives(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        D: math_Matrix

        Return
        -------
        bool

        Description
        -----------
        Returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_FunctionSetWithDerivatives_Derivatives(self, *args)

    def Values(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        F: math_Vector
        D: math_Matrix

        Return
        -------
        bool

        Description
        -----------
        returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_FunctionSetWithDerivatives_Values(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetWithDerivatives

# Register math_FunctionSetWithDerivatives in _math:
_math.math_FunctionSetWithDerivatives_swigregister(math_FunctionSetWithDerivatives)
class math_FunctionWithDerivative(math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivative(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        D: float

        Description
        -----------
        Computes the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.

        """
        return _math.math_FunctionWithDerivative_Derivative(self, *args)

    def Values(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        F: float
        D: float

        Description
        -----------
        Computes the value <F> and the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.

        """
        return _math.math_FunctionWithDerivative_Values(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionWithDerivative

# Register math_FunctionWithDerivative in _math:
_math.math_FunctionWithDerivative_swigregister(math_FunctionWithDerivative)
class math_MultipleVarFunctionWithGradient(math_MultipleVarFunction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Gradient(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Return
        -------
        bool

        Description
        -----------
        Computes the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_MultipleVarFunctionWithGradient_Gradient(self, *args)

    def Values(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Return
        -------
        F: float

        Description
        -----------
        computes the value <F> and the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_MultipleVarFunctionWithGradient_Values(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithGradient

# Register math_MultipleVarFunctionWithGradient in _math:
_math.math_MultipleVarFunctionWithGradient_swigregister(math_MultipleVarFunctionWithGradient)
class math_MultipleVarFunctionWithHessian(math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Values(self, *args):
        r"""

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Return
        -------
        F: float

        Description
        -----------
        computes the value <F> and the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        Parameters
        ----------
        X: math_Vector
        G: math_Vector
        H: math_Matrix

        Return
        -------
        F: float

        Description
        -----------
        computes the value <F>, the gradient <G> and the hessian <H> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        """
        return _math.math_MultipleVarFunctionWithHessian_Values(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithHessian

# Register math_MultipleVarFunctionWithHessian in _math:
_math.math_MultipleVarFunctionWithHessian_swigregister(math_MultipleVarFunctionWithHessian)
class math_TrigonometricEquationFunction(math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _math.math_TrigonometricEquationFunction_swiginit(self, _math.new_math_TrigonometricEquationFunction(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricEquationFunction

# Register math_TrigonometricEquationFunction in _math:
_math.math_TrigonometricEquationFunction_swigregister(math_TrigonometricEquationFunction)



@deprecated
def math_GaussPoints(*args):
	return math.GaussPoints(*args)

@deprecated
def math_GaussPointsMax(*args):
	return math.GaussPointsMax(*args)

@deprecated
def math_GaussWeights(*args):
	return math.GaussWeights(*args)

@deprecated
def math_KronrodPointsAndWeights(*args):
	return math.KronrodPointsAndWeights(*args)

@deprecated
def math_KronrodPointsMax(*args):
	return math.KronrodPointsMax(*args)

@deprecated
def math_OrderedGaussPointsAndWeights(*args):
	return math.OrderedGaussPointsAndWeights(*args)

@deprecated
def math_KronrodSingleIntegration_GKRule(*args):
	return math_KronrodSingleIntegration.GKRule(*args)



