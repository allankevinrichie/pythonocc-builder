# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
Law module, see official documentation at
https://dev.opencascade.org/doc/occt-7.9.0/refman/html/package_law.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Law
else:
    import _Law

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Law.delete_SwigPyIterator

    def value(self):
        return _Law.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Law.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Law.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Law.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Law.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Law.SwigPyIterator_copy(self)

    def next(self):
        return _Law.SwigPyIterator_next(self)

    def __next__(self):
        return _Law.SwigPyIterator___next__(self)

    def previous(self):
        return _Law.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Law.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Law.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Law.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Law.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Law.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Law.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Law.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Law:
_Law.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string

PYTHONOCC_DEBUG_EXCEPTIONS = _Law.PYTHONOCC_DEBUG_EXCEPTIONS

def get_readable_class_name(class_name):
    return _Law.get_readable_class_name(class_name)

def get_readable_method_name(method_name):
    return _Law.get_readable_method_name(method_name)

def get_exception_type(error):
    return _Law.get_exception_type(error)

def process_opencascade_exception(error, method_name, class_name):
    return _Law.process_opencascade_exception(error, method_name, class_name)

import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _Law.ios_base_erase_event
    imbue_event = _Law.ios_base_imbue_event
    copyfmt_event = _Law.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _Law.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _Law.ios_base_flags(self, *args)

    def setf(self, *args):
        return _Law.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _Law.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _Law.ios_base_precision(self, *args)

    def width(self, *args):
        return _Law.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _Law.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _Law.ios_base_imbue(self, __loc)

    def getloc(self):
        return _Law.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _Law.ios_base_xalloc()

    def iword(self, __ix):
        return _Law.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _Law.ios_base_pword(self, __ix)
    __swig_destroy__ = _Law.delete_ios_base

# Register ios_base in _Law:
_Law.ios_base_swigregister(ios_base)
cvar = _Law.cvar
ios_base.boolalpha = _Law.cvar.ios_base_boolalpha
ios_base.dec = _Law.cvar.ios_base_dec
ios_base.fixed = _Law.cvar.ios_base_fixed
ios_base.hex = _Law.cvar.ios_base_hex
ios_base.internal = _Law.cvar.ios_base_internal
ios_base.left = _Law.cvar.ios_base_left
ios_base.oct = _Law.cvar.ios_base_oct
ios_base.right = _Law.cvar.ios_base_right
ios_base.scientific = _Law.cvar.ios_base_scientific
ios_base.showbase = _Law.cvar.ios_base_showbase
ios_base.showpoint = _Law.cvar.ios_base_showpoint
ios_base.showpos = _Law.cvar.ios_base_showpos
ios_base.skipws = _Law.cvar.ios_base_skipws
ios_base.unitbuf = _Law.cvar.ios_base_unitbuf
ios_base.uppercase = _Law.cvar.ios_base_uppercase
ios_base.adjustfield = _Law.cvar.ios_base_adjustfield
ios_base.basefield = _Law.cvar.ios_base_basefield
ios_base.floatfield = _Law.cvar.ios_base_floatfield
ios_base.badbit = _Law.cvar.ios_base_badbit
ios_base.eofbit = _Law.cvar.ios_base_eofbit
ios_base.failbit = _Law.cvar.ios_base_failbit
ios_base.goodbit = _Law.cvar.ios_base_goodbit
ios_base.app = _Law.cvar.ios_base_app
ios_base.ate = _Law.cvar.ios_base_ate
ios_base.binary = _Law.cvar.ios_base_binary
ios_base.ios_base_in = _Law.cvar.ios_base_ios_base_in
ios_base.out = _Law.cvar.ios_base_out
ios_base.trunc = _Law.cvar.ios_base_trunc
ios_base.beg = _Law.cvar.ios_base_beg
ios_base.cur = _Law.cvar.ios_base_cur
ios_base.end = _Law.cvar.ios_base_end

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _Law.ios_rdstate(self)

    def clear(self, *args):
        return _Law.ios_clear(self, *args)

    def setstate(self, __state):
        return _Law.ios_setstate(self, __state)

    def good(self):
        return _Law.ios_good(self)

    def eof(self):
        return _Law.ios_eof(self)

    def fail(self):
        return _Law.ios_fail(self)

    def bad(self):
        return _Law.ios_bad(self)

    def exceptions(self, *args):
        return _Law.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _Law.ios_swiginit(self, _Law.new_ios(__sb))
    __swig_destroy__ = _Law.delete_ios

    def tie(self, *args):
        return _Law.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _Law.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _Law.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _Law.ios_fill(self, *args)

    def imbue(self, __loc):
        return _Law.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _Law.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _Law.ios_widen(self, __c)

# Register ios in _Law:
_Law.ios_swigregister(ios)
class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Law.ostream_swiginit(self, _Law.new_ostream(__sb))
    __swig_destroy__ = _Law.delete_ostream

    def __lshift__(self, *args):
        return _Law.ostream___lshift__(self, *args)

    def put(self, __c):
        return _Law.ostream_put(self, __c)

    def write(self, __s, __n):
        return _Law.ostream_write(self, __s, __n)

    def flush(self):
        return _Law.ostream_flush(self)

    def tellp(self):
        return _Law.ostream_tellp(self)

    def seekp(self, *args):
        return _Law.ostream_seekp(self, *args)

# Register ostream in _Law:
_Law.ostream_swigregister(ostream)
class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Law.istream_swiginit(self, _Law.new_istream(__sb))
    __swig_destroy__ = _Law.delete_istream

    def __rshift__(self, *args):
        return _Law.istream___rshift__(self, *args)

    def gcount(self):
        return _Law.istream_gcount(self)

    def get(self, *args):
        return _Law.istream_get(self, *args)

    def getline(self, *args):
        return _Law.istream_getline(self, *args)

    def ignore(self, *args):
        return _Law.istream_ignore(self, *args)

    def peek(self):
        return _Law.istream_peek(self)

    def read(self, __s, __n):
        return _Law.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _Law.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _Law.istream_putback(self, __c)

    def unget(self):
        return _Law.istream_unget(self)

    def sync(self):
        return _Law.istream_sync(self)

    def tellg(self):
        return _Law.istream_tellg(self)

    def seekg(self, *args):
        return _Law.istream_seekg(self, *args)

# Register istream in _Law:
_Law.istream_swigregister(istream)
class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Law.iostream_swiginit(self, _Law.new_iostream(__sb))
    __swig_destroy__ = _Law.delete_iostream

# Register iostream in _Law:
_Law.iostream_swigregister(iostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

endl_cb_ptr = _Law.endl_cb_ptr
endl = _Law.endl
ends_cb_ptr = _Law.ends_cb_ptr
ends = _Law.ends
flush_cb_ptr = _Law.flush_cb_ptr
flush = _Law.flush
import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD

from enum import IntEnum
from OCC.Core.Exception import *




def Handle_Law_BSpline_Create():
    return _Law.Handle_Law_BSpline_Create()

def Handle_Law_BSpline_DownCast(t):
    return _Law.Handle_Law_BSpline_DownCast(t)

def Handle_Law_BSpline_IsNull(t):
    return _Law.Handle_Law_BSpline_IsNull(t)

def Handle_Law_BSpline_ForceRelease(t):
    return _Law.Handle_Law_BSpline_ForceRelease(t)

def Handle_Law_BSpline_GetRefCount(t):
    return _Law.Handle_Law_BSpline_GetRefCount(t)

def Handle_Law_Function_Create():
    return _Law.Handle_Law_Function_Create()

def Handle_Law_Function_DownCast(t):
    return _Law.Handle_Law_Function_DownCast(t)

def Handle_Law_Function_IsNull(t):
    return _Law.Handle_Law_Function_IsNull(t)

def Handle_Law_Function_ForceRelease(t):
    return _Law.Handle_Law_Function_ForceRelease(t)

def Handle_Law_Function_GetRefCount(t):
    return _Law.Handle_Law_Function_GetRefCount(t)

def Handle_Law_BSpFunc_Create():
    return _Law.Handle_Law_BSpFunc_Create()

def Handle_Law_BSpFunc_DownCast(t):
    return _Law.Handle_Law_BSpFunc_DownCast(t)

def Handle_Law_BSpFunc_IsNull(t):
    return _Law.Handle_Law_BSpFunc_IsNull(t)

def Handle_Law_BSpFunc_ForceRelease(t):
    return _Law.Handle_Law_BSpFunc_ForceRelease(t)

def Handle_Law_BSpFunc_GetRefCount(t):
    return _Law.Handle_Law_BSpFunc_GetRefCount(t)

def Handle_Law_Composite_Create():
    return _Law.Handle_Law_Composite_Create()

def Handle_Law_Composite_DownCast(t):
    return _Law.Handle_Law_Composite_DownCast(t)

def Handle_Law_Composite_IsNull(t):
    return _Law.Handle_Law_Composite_IsNull(t)

def Handle_Law_Composite_ForceRelease(t):
    return _Law.Handle_Law_Composite_ForceRelease(t)

def Handle_Law_Composite_GetRefCount(t):
    return _Law.Handle_Law_Composite_GetRefCount(t)

def Handle_Law_Constant_Create():
    return _Law.Handle_Law_Constant_Create()

def Handle_Law_Constant_DownCast(t):
    return _Law.Handle_Law_Constant_DownCast(t)

def Handle_Law_Constant_IsNull(t):
    return _Law.Handle_Law_Constant_IsNull(t)

def Handle_Law_Constant_ForceRelease(t):
    return _Law.Handle_Law_Constant_ForceRelease(t)

def Handle_Law_Constant_GetRefCount(t):
    return _Law.Handle_Law_Constant_GetRefCount(t)

def Handle_Law_Linear_Create():
    return _Law.Handle_Law_Linear_Create()

def Handle_Law_Linear_DownCast(t):
    return _Law.Handle_Law_Linear_DownCast(t)

def Handle_Law_Linear_IsNull(t):
    return _Law.Handle_Law_Linear_IsNull(t)

def Handle_Law_Linear_ForceRelease(t):
    return _Law.Handle_Law_Linear_ForceRelease(t)

def Handle_Law_Linear_GetRefCount(t):
    return _Law.Handle_Law_Linear_GetRefCount(t)

def Handle_Law_Interpol_Create():
    return _Law.Handle_Law_Interpol_Create()

def Handle_Law_Interpol_DownCast(t):
    return _Law.Handle_Law_Interpol_DownCast(t)

def Handle_Law_Interpol_IsNull(t):
    return _Law.Handle_Law_Interpol_IsNull(t)

def Handle_Law_Interpol_ForceRelease(t):
    return _Law.Handle_Law_Interpol_ForceRelease(t)

def Handle_Law_Interpol_GetRefCount(t):
    return _Law.Handle_Law_Interpol_GetRefCount(t)

def Handle_Law_S_Create():
    return _Law.Handle_Law_S_Create()

def Handle_Law_S_DownCast(t):
    return _Law.Handle_Law_S_DownCast(t)

def Handle_Law_S_IsNull(t):
    return _Law.Handle_Law_S_IsNull(t)

def Handle_Law_S_ForceRelease(t):
    return _Law.Handle_Law_S_ForceRelease(t)

def Handle_Law_S_GetRefCount(t):
    return _Law.Handle_Law_S_GetRefCount(t)
class Law_Laws(OCC.Core.NCollection.NCollection_BaseList):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self):
        return _Law.Law_Laws_begin(self)

    def end(self):
        return _Law.Law_Laws_end(self)

    def cbegin(self):
        return _Law.Law_Laws_cbegin(self)

    def cend(self):
        return _Law.Law_Laws_cend(self)

    def __init__(self, *args):
        _Law.Law_Laws_swiginit(self, _Law.new_Law_Laws(*args))

    def Size(self):
        return _Law.Law_Laws_Size(self)

    def Assign(self, theOther):
        return _Law.Law_Laws_Assign(self, theOther)

    def Set(self, *args):
        return _Law.Law_Laws_Set(self, *args)

    def Clear(self, theAllocator=0):
        return _Law.Law_Laws_Clear(self, theAllocator)

    def First(self):
        return _Law.Law_Laws_First(self)

    def Last(self):
        return _Law.Law_Laws_Last(self)

    def Append(self, *args):
        return _Law.Law_Laws_Append(self, *args)

    def Prepend(self, *args):
        return _Law.Law_Laws_Prepend(self, *args)

    def RemoveFirst(self):
        return _Law.Law_Laws_RemoveFirst(self)

    def Remove(self, theIter):
        return _Law.Law_Laws_Remove(self, theIter)

    def InsertBefore(self, *args):
        return _Law.Law_Laws_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        return _Law.Law_Laws_InsertAfter(self, *args)

    def Reverse(self):
        return _Law.Law_Laws_Reverse(self)
    __swig_destroy__ = _Law.delete_Law_Laws

    def __len__(self):
        return self.Size()

    def __iter__(self):
        it = Law_ListIteratorOfLaws(self.this)
        while it.More():
            yield it.Value()
            it.Next()


# Register Law_Laws in _Law:
_Law.Law_Laws_swigregister(Law_Laws)
class Law_ListIteratorOfLaws(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Law.Law_ListIteratorOfLaws_swiginit(self, _Law.new_Law_ListIteratorOfLaws(*args))

    def More(self):
        return _Law.Law_ListIteratorOfLaws_More(self)

    def Next(self):
        return _Law.Law_ListIteratorOfLaws_Next(self)

    def Value(self):
        return _Law.Law_ListIteratorOfLaws_Value(self)

    def ChangeValue(self):
        return _Law.Law_ListIteratorOfLaws_ChangeValue(self)
    __swig_destroy__ = _Law.delete_Law_ListIteratorOfLaws

# Register Law_ListIteratorOfLaws in _Law:
_Law.Law_ListIteratorOfLaws_swigregister(Law_ListIteratorOfLaws)
class law(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def MixBnd(*args):
        r"""

        Parameters
        ----------
        Lin: Law_Linear

        Return
        -------
        opencascade::handle<Law_BSpFunc>

        Description
        -----------
        This algorithm searches the knot values corresponding to the splitting of a given B-spline law into several arcs with the same continuity. The continuity order is given at the construction time. Builds a 1d bspline that is near from Lin with null derivatives at the extremities.

        Parameters
        ----------
        Degree: int
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        Lin: Law_Linear

        Return
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        Description
        -----------
        Builds the poles of the 1d bspline that is near from Lin with null derivatives at the extremities.

        """
        return _Law.law_MixBnd(*args)

    @staticmethod
    def MixTgt(*args):
        r"""

        Parameters
        ----------
        Degree: int
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        NulOnTheRight: bool
        Index: int

        Return
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        Description
        -----------
        Builds the poles of the 1d bspline that is null on the right side of Knots(Index) (on the left if NulOnTheRight is false) and that is like a t*(1-t)(1-t) curve on the left side of Knots(Index) (on the right if NulOnTheRight is false). The result curve is C1 with a derivative equal to 1. at first parameter (-1 at last parameter if NulOnTheRight is false). Warning: Mults(Index) must greater or equal to degree-1.

        """
        return _Law.law_MixTgt(*args)

    @staticmethod
    def Reparametrize(*args):
        r"""

        Parameters
        ----------
        Curve: Adaptor3d_Curve
        First: float
        Last: float
        HasDF: bool
        HasDL: bool
        DFirst: float
        DLast: float
        Rev: bool
        NbPoints: int

        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        Computes a 1 d curve to reparametrize a curve. Its an interpolation of NbPoints points calculated at quasi constant abscissa.

        """
        return _Law.law_Reparametrize(*args)

    @staticmethod
    def Scale(*args):
        r"""

        Parameters
        ----------
        First: float
        Last: float
        HasF: bool
        HasL: bool
        VFirst: float
        VLast: float

        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        Computes a 1 d curve to scale a field of tangency. Value is 1. for t = (First+Last)/2 . If HasFirst value for t = First is VFirst (null derivative). If HasLast value for t = Last is VLast (null derivative). //! 1.  _ _/ \_ __/ \__ / VFirst ____/ VLast \____ First  Last.

        """
        return _Law.law_Scale(*args)

    @staticmethod
    def ScaleCub(*args):
        r"""

        Parameters
        ----------
        First: float
        Last: float
        HasF: bool
        HasL: bool
        VFirst: float
        VLast: float

        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        No available documentation.

        """
        return _Law.law_ScaleCub(*args)

    __repr__ = _dumps_object


    def __init__(self):
        _Law.law_swiginit(self, _Law.new_law())
    __swig_destroy__ = _Law.delete_law

# Register law in _Law:
_Law.law_swigregister(law)
class Law_BSpline(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColStd_Array1OfReal
        Knots: TColStd_Array1OfReal
        Multiplicities: TColStd_Array1OfInteger
        Degree: int
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Creates a non-rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.

        Parameters
        ----------
        Poles: TColStd_Array1OfReal
        Weights: TColStd_Array1OfReal
        Knots: TColStd_Array1OfReal
        Multiplicities: TColStd_Array1OfInteger
        Degree: int
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.

        """
        _Law.Law_BSpline_swiginit(self, _Law.new_Law_BSpline(*args))

    def Continuity(self, *args):
        r"""
        Return
        -------
        GeomAbs_Shape

        Description
        -----------
        Returns the global continuity of the curve: C0: only geometric continuity, C1: continuity of the first derivative all along the Curve, C2: continuity of the second derivative all along the Curve, C3: continuity of the third derivative all along the Curve, CN: the order of continuity is infinite. For a B-spline curve of degree d if a knot Ui has a multiplicity p the B-spline curve is only Cd-p continuous at Ui. So the global continuity of the curve can't be greater than Cd-p where p is the maximum multiplicity of the interior Knots. In the interior of a knot span the curve is infinitely continuously differentiable.

        """
        return _Law.Law_BSpline_Continuity(self, *args)

    def Copy(self, *args):
        r"""
        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_Copy(self, *args)

    def D0(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        P: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_D0(self, *args)

    def D1(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        P: float
        V1: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_D1(self, *args)

    def D2(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        P: float
        V1: float
        V2: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_D2(self, *args)

    def D3(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        P: float
        V1: float
        V2: float
        V3: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_D3(self, *args)

    def DN(self, *args):
        r"""

        Parameters
        ----------
        U: float
        N: int

        Return
        -------
        float

        Description
        -----------
        The following functions computes the point of parameter U and the derivatives at this point on the B-spline curve arc defined between the knot FromK1 and the knot ToK2. U can be out of bounds [Knot (FromK1), Knot (ToK2)] but for the computation we only use the definition of the curve between these two knots. This method is useful to compute local derivative, if the order of continuity of the whole curve is not greater enough. Inside the parametric domain Knot (FromK1), Knot (ToK2) the evaluations are the same as if we consider the whole definition of the curve. Of course the evaluations are different outside this parametric domain.

        """
        return _Law.Law_BSpline_DN(self, *args)

    def Degree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Computation of value and derivatives.

        """
        return _Law.Law_BSpline_Degree(self, *args)

    def EndPoint(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the last point of the curve. Warnings: The last point of the curve is different from the last pole of the curve if the multiplicity of the last knot is lower than Degree.

        """
        return _Law.Law_BSpline_EndPoint(self, *args)

    def FirstParameter(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Computes the parametric value of the start point of the curve. It is a knot value.

        """
        return _Law.Law_BSpline_FirstParameter(self, *args)

    def FirstUKnotIndex(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        For a B-spline curve the first parameter (which gives the start point of the curve) is a knot value but if the multiplicity of the first knot index is lower than Degree + 1 it is not the first knot of the curve. This method computes the index of the knot corresponding to the first parameter.

        """
        return _Law.Law_BSpline_FirstUKnotIndex(self, *args)

    def IncreaseDegree(self, *args):
        r"""

        Parameters
        ----------
        Degree: int

        Return
        -------
        None

        Description
        -----------
        Increase the degree to <Degree>. Nothing is done if <Degree> is lower or equal to the current degree.

        """
        return _Law.Law_BSpline_IncreaseDegree(self, *args)

    def IncreaseMultiplicity(self, *args):
        r"""

        Parameters
        ----------
        Index: int
        M: int

        Return
        -------
        None

        Description
        -----------
        Increases the multiplicity of the knot <Index> to <M>. //! If <M> is lower or equal to the current multiplicity nothing is done. If <M> is higher than the degree the degree is used. If <Index> is not in [FirstUKnotIndex, LastUKnotIndex].

        Parameters
        ----------
        I1: int
        I2: int
        M: int

        Return
        -------
        None

        Description
        -----------
        Increases the multiplicities of the knots in [I1,I2] to <M>. //! For each knot if <M> is lower or equal to the current multiplicity nothing is done. If <M> is higher than the degree the degree is used. If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex].

        """
        return _Law.Law_BSpline_IncreaseMultiplicity(self, *args)

    def IncrementMultiplicity(self, *args):
        r"""

        Parameters
        ----------
        I1: int
        I2: int
        M: int

        Return
        -------
        None

        Description
        -----------
        Increment the multiplicities of the knots in [I1,I2] by <M>. //! If <M> is not positive nithing is done. //! For each knot the resulting multiplicity is limited to the Degree. If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex].

        """
        return _Law.Law_BSpline_IncrementMultiplicity(self, *args)

    def InsertKnot(self, *args):
        r"""

        Parameters
        ----------
        U: float
        M: int (optional, default to 1)
        ParametricTolerance: float (optional, default to 0.0)
        Add: bool (optional, default to Standard_True)

        Return
        -------
        None

        Description
        -----------
        Inserts a knot value in the sequence of knots. If <U> is an existing knot the multiplicity is increased by <M>. //! If U is not on the parameter range nothing is done. //! If the multiplicity is negative or null nothing is done. The new multiplicity is limited to the degree. //! The tolerance criterion for knots equality is the max of Epsilon(U) and ParametricTolerance.

        """
        return _Law.Law_BSpline_InsertKnot(self, *args)

    def InsertKnots(self, *args):
        r"""

        Parameters
        ----------
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        ParametricTolerance: float (optional, default to 0.0)
        Add: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Inserts a set of knots values in the sequence of knots. //! For each U = Knots(i), M = Mults(i) //! If <U> is an existing knot the multiplicity is increased by <M> if <Add> is True, increased to <M> if <Add> is False. //! If U is not on the parameter range nothing is done. //! If the multiplicity is negative or null nothing is done. The new multiplicity is limited to the degree. //! The tolerance criterion for knots equality is the max of Epsilon(U) and ParametricTolerance.

        """
        return _Law.Law_BSpline_InsertKnots(self, *args)

    def IsCN(self, *args):
        r"""

        Parameters
        ----------
        N: int

        Return
        -------
        bool

        Description
        -----------
        Returns the continuity of the curve, the curve is at least C0. Raised if N < 0.

        """
        return _Law.Law_BSpline_IsCN(self, *args)

    def IsClosed(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the distance between the first point and the last point of the curve is lower or equal to Resolution from package gp. Warnings: The first and the last point can be different from the first pole and the last pole of the curve.

        """
        return _Law.Law_BSpline_IsClosed(self, *args)

    def IsPeriodic(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns True if the curve is periodic.

        """
        return _Law.Law_BSpline_IsPeriodic(self, *args)

    def IsRational(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns True if the weights are not identical. The tolerance criterion is Epsilon of the class Real.

        """
        return _Law.Law_BSpline_IsRational(self, *args)

    def Knot(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the knot of range Index. When there is a knot with a multiplicity greater than 1 the knot is not repeated. The method Multiplicity can be used to get the multiplicity of the Knot. Raised if Index < 1 or Index > NbKnots.

        """
        return _Law.Law_BSpline_Knot(self, *args)

    def KnotDistribution(self, *args):
        r"""
        Return
        -------
        GeomAbs_BSplKnotDistribution

        Description
        -----------
        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot the BSpline Curve can be: - Uniform if all the knots are of multiplicity 1, - QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1, - PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree A piecewise Bezier with only two knots is a BezierCurve. else the curve is non uniform. The tolerance criterion is Epsilon from class Real.

        """
        return _Law.Law_BSpline_KnotDistribution(self, *args)

    def KnotSequence(self, *args):
        r"""

        Parameters
        ----------
        K: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        Returns the knots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example: K = {k1, k1, k1, k2, k3, k3, k4, k4, k4} //! Raised if the length of K is not equal to NbPoles + Degree + 1.

        """
        return _Law.Law_BSpline_KnotSequence(self, *args)

    def Knots(self, *args):
        r"""

        Parameters
        ----------
        K: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        returns the knot values of the B-spline curve; //! Raised if the length of K is not equal to the number of knots.

        """
        return _Law.Law_BSpline_Knots(self, *args)

    def LastParameter(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Computes the parametric value of the end point of the curve. It is a knot value.

        """
        return _Law.Law_BSpline_LastParameter(self, *args)

    def LastUKnotIndex(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        For a BSpline curve the last parameter (which gives the end point of the curve) is a knot value but if the multiplicity of the last knot index is lower than Degree + 1 it is not the last knot of the curve. This method computes the index of the knot corresponding to the last parameter.

        """
        return _Law.Law_BSpline_LastUKnotIndex(self, *args)

    def LocalD0(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int

        Return
        -------
        P: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalD0(self, *args)

    def LocalD1(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int

        Return
        -------
        P: float
        V1: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalD1(self, *args)

    def LocalD2(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int

        Return
        -------
        P: float
        V1: float
        V2: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalD2(self, *args)

    def LocalD3(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int

        Return
        -------
        P: float
        V1: float
        V2: float
        V3: float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalD3(self, *args)

    def LocalDN(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int
        N: int

        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalDN(self, *args)

    def LocalValue(self, *args):
        r"""

        Parameters
        ----------
        U: float
        FromK1: int
        ToK2: int

        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_LocalValue(self, *args)

    def LocateU(self, *args):
        r"""

        Parameters
        ----------
        U: float
        ParametricTolerance: float
        WithKnotRepetition: bool (optional, default to Standard_False)

        Return
        -------
        I1: int
        I2: int

        Description
        -----------
        Locates the parametric value U in the sequence of knots. If 'WithKnotRepetition' is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. Knots (I1) <= U <= Knots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 < 1 => U < Knots (1) - Abs(ParametricTolerance) . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance).

        """
        return _Law.Law_BSpline_LocateU(self, *args)

    @staticmethod
    def MaxDegree(*args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the value of the maximum degree of the normalized B-spline basis functions in this package.

        """
        return _Law.Law_BSpline_MaxDegree(*args)

    def MovePointAndTangent(self, *args):
        r"""

        Parameters
        ----------
        U: float
        NewValue: float
        Derivative: float
        Tolerance: float
        StartingCondition: int
        EndingCondition: int

        Return
        -------
        ErrorStatus: int

        Description
        -----------
        Changes the value of the Law at parameter U to NewValue. and makes its derivative at U be derivative. StartingCondition = -1 means first can move EndingCondition = -1 means last point can move StartingCondition = 0 means the first point cannot move EndingCondition = 0 means the last point cannot move StartingCondition = 1 means the first point and tangent cannot move EndingCondition = 1 means the last point and tangent cannot move and so forth ErrorStatus != 0 means that there are not enough degree of freedom with the constrain to deform the curve accordingly.

        """
        return _Law.Law_BSpline_MovePointAndTangent(self, *args)

    def Multiplicities(self, *args):
        r"""

        Parameters
        ----------
        M: TColStd_Array1OfInteger

        Return
        -------
        None

        Description
        -----------
        Returns the multiplicity of the knots of the curve. //! Raised if the length of M is not equal to NbKnots.

        """
        return _Law.Law_BSpline_Multiplicities(self, *args)

    def Multiplicity(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        int

        Description
        -----------
        Returns the multiplicity of the knots of range Index. Raised if Index < 1 or Index > NbKnots.

        """
        return _Law.Law_BSpline_Multiplicity(self, *args)

    def NbKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots. This method returns the number of knot without repetition of multiple knots.

        """
        return _Law.Law_BSpline_NbKnots(self, *args)

    def NbPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of poles.

        """
        return _Law.Law_BSpline_NbPoles(self, *args)

    def PeriodicNormalization(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        U: float

        Description
        -----------
        returns the parameter normalized within the period if the curve is periodic: otherwise does not do anything.

        """
        return _Law.Law_BSpline_PeriodicNormalization(self, *args)

    def Pole(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the pole of range Index. Raised if Index < 1 or Index > NbPoles.

        """
        return _Law.Law_BSpline_Pole(self, *args)

    def Poles(self, *args):
        r"""

        Parameters
        ----------
        P: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        Returns the poles of the B-spline curve; //! Raised if the length of P is not equal to the number of poles.

        """
        return _Law.Law_BSpline_Poles(self, *args)

    def RemoveKnot(self, *args):
        r"""

        Parameters
        ----------
        Index: int
        M: int
        Tolerance: float

        Return
        -------
        bool

        Description
        -----------
        Decrement the knots multiplicity to <M>. If M is 0 the knot is removed. The Poles sequence is modified. //! As there are two ways to compute the new poles the average is computed if the distance is lower than the <Tolerance>, else False is returned. //! A low tolerance is used to prevent the modification of the curve. //! A high tolerance is used to 'smooth' the curve. //! Raised if Index is not in the range [FirstUKnotIndex, LastUKnotIndex] pole insertion and pole removing this operation is limited to the Uniform or QuasiUniform BSplineCurve. The knot values are modified . If the BSpline is NonUniform or Piecewise Bezier an exception Construction error is raised.

        """
        return _Law.Law_BSpline_RemoveKnot(self, *args)

    def Resolution(self, *args):
        r"""

        Parameters
        ----------
        Tolerance3D: float

        Return
        -------
        UTolerance: float

        Description
        -----------
        given Tolerance3D returns UTolerance such that if f(t) is the curve we have | t1 - t0| < Utolerance ===> |f(t1) - f(t0)| < Tolerance3D.

        """
        return _Law.Law_BSpline_Resolution(self, *args)

    def Reverse(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Changes the direction of parametrization of <self>. The Knot sequence is modified, the FirstParameter and the LastParameter are not modified. The StartPoint of the initial curve becomes the EndPoint of the reversed curve and the EndPoint of the initial curve becomes the StartPoint of the reversed curve.

        """
        return _Law.Law_BSpline_Reverse(self, *args)

    def ReversedParameter(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        float

        Description
        -----------
        Returns the parameter on the reversed curve for the point of parameter U on <self>. //! returns UFirst + ULast - U.

        """
        return _Law.Law_BSpline_ReversedParameter(self, *args)

    def Segment(self, *args):
        r"""

        Parameters
        ----------
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        Segments the curve between U1 and U2. The control points are modified, the first and the last point are not the same. Warnings: Even if <self> is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the curve <self> or if the curve makes loop. After the segmentation the length of a curve can be null. raises if U2 < U1.

        """
        return _Law.Law_BSpline_Segment(self, *args)

    def SetKnot(self, *args):
        r"""

        Parameters
        ----------
        Index: int
        K: float

        Return
        -------
        None

        Description
        -----------
        Changes the knot of range Index. The multiplicity of the knot is not modified. Raised if K >= Knots(Index+1) or K <= Knots(Index-1). Raised if Index < 1 || Index > NbKnots.

        Parameters
        ----------
        Index: int
        K: float
        M: int

        Return
        -------
        None

        Description
        -----------
        Changes the knot of range Index with its multiplicity. You can increase the multiplicity of a knot but it is not allowed to decrease the multiplicity of an existing knot. //! Raised if K >= Knots(Index+1) or K <= Knots(Index-1). Raised if M is greater than Degree or lower than the previous multiplicity of knot of range Index. Raised if Index < 1 || Index > NbKnots.

        """
        return _Law.Law_BSpline_SetKnot(self, *args)

    def SetKnots(self, *args):
        r"""

        Parameters
        ----------
        K: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        Changes all the knots of the curve The multiplicity of the knots are not modified. //! Raised if there is an index such that K (Index+1) <= K (Index). //! Raised if K.Lower() < 1 or K.Upper() > NbKnots.

        """
        return _Law.Law_BSpline_SetKnots(self, *args)

    def SetNotPeriodic(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Makes a non periodic curve. If the curve was non periodic the curve is not modified.

        """
        return _Law.Law_BSpline_SetNotPeriodic(self, *args)

    def SetOrigin(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        None

        Description
        -----------
        Set the origin of a periodic curve at Knot(index) KnotVector and poles are modified. Raised if the curve is not periodic Raised if index not in the range [FirstUKnotIndex , LastUKnotIndex].

        """
        return _Law.Law_BSpline_SetOrigin(self, *args)

    def SetPeriodic(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Makes a closed B-spline into a periodic curve. The curve is periodic if the knot sequence is periodic and if the curve is closed (The tolerance criterion is Resolution from gp). The period T is equal to Knot(LastUKnotIndex) - Knot(FirstUKnotIndex). A periodic B-spline can be uniform or not. Raised if the curve is not closed.

        """
        return _Law.Law_BSpline_SetPeriodic(self, *args)

    def SetPole(self, *args):
        r"""

        Parameters
        ----------
        Index: int
        P: float

        Return
        -------
        None

        Description
        -----------
        Substitutes the Pole of range Index with P. //! Raised if Index < 1 || Index > NbPoles.

        Parameters
        ----------
        Index: int
        P: float
        Weight: float

        Return
        -------
        None

        Description
        -----------
        Substitutes the pole and the weight of range Index. If the curve <self> is not rational it can become rational If the curve was rational it can become non rational //! Raised if Index < 1 || Index > NbPoles Raised if Weight <= 0.0.

        """
        return _Law.Law_BSpline_SetPole(self, *args)

    def SetWeight(self, *args):
        r"""

        Parameters
        ----------
        Index: int
        Weight: float

        Return
        -------
        None

        Description
        -----------
        Changes the weight for the pole of range Index. If the curve was non rational it can become rational. If the curve was rational it can become non rational. //! Raised if Index < 1 || Index > NbPoles Raised if Weight <= 0.0.

        """
        return _Law.Law_BSpline_SetWeight(self, *args)

    def StartPoint(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the start point of the curve. Warnings: This point is different from the first pole of the curve if the multiplicity of the first knot is lower than Degree.

        """
        return _Law.Law_BSpline_StartPoint(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        U: float

        Return
        -------
        float

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpline_Value(self, *args)

    def Weight(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the weight of the pole of range Index . Raised if Index < 1 or Index > NbPoles.

        """
        return _Law.Law_BSpline_Weight(self, *args)

    def Weights(self, *args):
        r"""

        Parameters
        ----------
        W: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        Returns the weights of the B-spline curve; //! Raised if the length of W is not equal to NbPoles.

        """
        return _Law.Law_BSpline_Weights(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_BSpline_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSpline

# Register Law_BSpline in _Law:
_Law.Law_BSpline_swigregister(Law_BSpline)
class Law_BSplineKnotSplitting(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        BasisLaw: Law_BSpline
        ContinuityRange: int

        Return
        -------
        None

        Description
        -----------
        Locates the knot values which correspond to the segmentation of the curve into arcs with a continuity equal to ContinuityRange. //! Raised if ContinuityRange is not greater or equal zero.

        """
        _Law.Law_BSplineKnotSplitting_swiginit(self, _Law.new_Law_BSplineKnotSplitting(*args))

    def NbSplits(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots corresponding to the splitting.

        """
        return _Law.Law_BSplineKnotSplitting_NbSplits(self, *args)

    def SplitValue(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        int

        Description
        -----------
        Returns the index of the knot corresponding to the splitting of range Index. //! Raised if Index < 1 or Index > NbSplits.

        """
        return _Law.Law_BSplineKnotSplitting_SplitValue(self, *args)

    def Splitting(self, *args):
        r"""

        Parameters
        ----------
        SplitValues: TColStd_Array1OfInteger

        Return
        -------
        None

        Description
        -----------
        Returns the indexes of the BSpline curve knots corresponding to the splitting. //! Raised if the length of SplitValues is not equal to NbSPlit.

        """
        return _Law.Law_BSplineKnotSplitting_Splitting(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSplineKnotSplitting

# Register Law_BSplineKnotSplitting in _Law:
_Law.Law_BSplineKnotSplitting_swigregister(Law_BSplineKnotSplitting)
class Law_Function(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Bounds(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        PFirst: float
        PLast: float

        Description
        -----------
        Returns the parametric bounds of the function.

        """
        return _Law.Law_Function_Bounds(self, *args)

    def Continuity(self, *args):
        r"""
        Return
        -------
        GeomAbs_Shape

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Function_Continuity(self, *args)

    def D1(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        F: float
        D: float

        Description
        -----------
        Returns the value F and the first derivative D of the function at the point of parameter X.

        """
        return _Law.Law_Function_D1(self, *args)

    def D2(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        F: float
        D: float
        D2: float

        Description
        -----------
        Returns the value, first and seconde derivatives at parameter X.

        """
        return _Law.Law_Function_D2(self, *args)

    def Intervals(self, *args):
        r"""

        Parameters
        ----------
        T: TColStd_Array1OfReal
        S: GeomAbs_Shape

        Return
        -------
        None

        Description
        -----------
        Stores in <T> the parameters bounding the intervals of continuity <S>. The array must provide enough room to accommodate for the parameters, i.e. T.Length() > NbIntervals().

        """
        return _Law.Law_Function_Intervals(self, *args)

    def NbIntervals(self, *args):
        r"""

        Parameters
        ----------
        S: GeomAbs_Shape

        Return
        -------
        int

        Description
        -----------
        Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>.

        """
        return _Law.Law_Function_NbIntervals(self, *args)

    def Trim(self, *args):
        r"""

        Parameters
        ----------
        PFirst: float
        PLast: float
        Tol: float

        Return
        -------
        opencascade::handle<Law_Function>

        Description
        -----------
        Returns a law equivalent of <self> between parameters <First> and <Last>. <Tol> is used to test for 3d points confusion. It is usfule to determines the derivatives in these values <First> and <Last> if the Law is not Cn.

        """
        return _Law.Law_Function_Trim(self, *args)

    def Value(self, *args):
        r"""

        Parameters
        ----------
        X: float

        Return
        -------
        float

        Description
        -----------
        Returns the value of the function at the point of parameter X.

        """
        return _Law.Law_Function_Value(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Function_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Function

# Register Law_Function in _Law:
_Law.Law_Function_swigregister(Law_Function)
class Law_Interpolate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Points: TColStd_HArray1OfReal
        PeriodicFlag: bool
        Tolerance: float

        Return
        -------
        None

        Description
        -----------
        Tolerance is to check if the points are not too close to one an other. It is also used to check if the tangent vector is not too small. There should be at least 2 points. If PeriodicFlag is True then the curve will be periodic be periodic.

        Parameters
        ----------
        Points: TColStd_HArray1OfReal
        Parameters: TColStd_HArray1OfReal
        PeriodicFlag: bool
        Tolerance: float

        Return
        -------
        None

        Description
        -----------
        Tolerance is to check if the points are not too close to one an other. It is also used to check if the tangent vector is not too small. There should be at least 2 points. If PeriodicFlag is True then the curve will be periodic be periodic.

        """
        _Law.Law_Interpolate_swiginit(self, _Law.new_Law_Interpolate(*args))

    def Curve(self, *args):
        r"""
        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Interpolate_Curve(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Interpolate_IsDone(self, *args)

    def Load(self, *args):
        r"""

        Parameters
        ----------
        InitialTangent: float
        FinalTangent: float

        Return
        -------
        None

        Description
        -----------
        loads initial and final tangents if any.

        Parameters
        ----------
        Tangents: TColStd_Array1OfReal
        TangentFlags: TColStd_HArray1OfBoolean

        Return
        -------
        None

        Description
        -----------
        loads the tangents. We should have as many tangents as they are points in the array if TangentFlags.Value(i) is Standard_True use the tangent Tangents.Value(i) otherwise the tangent is not constrained.

        """
        return _Law.Law_Interpolate_Load(self, *args)

    def Perform(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Makes the interpolation.

        """
        return _Law.Law_Interpolate_Perform(self, *args)

    __repr__ = _dumps_object

    @methodnotwrapped
    def ClearTangents(self):
    	pass

    __swig_destroy__ = _Law.delete_Law_Interpolate

# Register Law_Interpolate in _Law:
_Law.Law_Interpolate_swigregister(Law_Interpolate)
class Law_BSpFunc(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        C: Law_BSpline
        First: float
        Last: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _Law.Law_BSpFunc_swiginit(self, _Law.new_Law_BSpFunc(*args))

    def Curve(self, *args):
        r"""
        Return
        -------
        opencascade::handle<Law_BSpline>

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpFunc_Curve(self, *args)

    def SetCurve(self, *args):
        r"""

        Parameters
        ----------
        C: Law_BSpline

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_BSpFunc_SetCurve(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_BSpFunc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSpFunc

# Register Law_BSpFunc in _Law:
_Law.Law_BSpFunc_swigregister(Law_BSpFunc)
class Law_Composite(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Construct an empty Law.

        Parameters
        ----------
        First: float
        Last: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Construct an empty, trimmed Law.

        """
        _Law.Law_Composite_swiginit(self, _Law.new_Law_Composite(*args))

    def ChangeElementaryLaw(self, *args):
        r"""

        Parameters
        ----------
        W: float

        Return
        -------
        opencascade::handle<Law_Function>

        Description
        -----------
        Returns the elementary function of the composite used to compute at parameter W.

        """
        return _Law.Law_Composite_ChangeElementaryLaw(self, *args)

    def ChangeLaws(self, *args):
        r"""
        Return
        -------
        Law_Laws

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Composite_ChangeLaws(self, *args)

    def IsPeriodic(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Composite_IsPeriodic(self, *args)

    def SetPeriodic(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Composite_SetPeriodic(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Composite_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Composite

# Register Law_Composite in _Law:
_Law.Law_Composite_swigregister(Law_Composite)
class Law_Constant(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _Law.Law_Constant_swiginit(self, _Law.new_Law_Constant(*args))

    def Set(self, *args):
        r"""

        Parameters
        ----------
        Radius: float
        PFirst: float
        PLast: float

        Return
        -------
        None

        Description
        -----------
        Set the radius and the range of the constant Law.

        """
        return _Law.Law_Constant_Set(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Constant_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Constant

# Register Law_Constant in _Law:
_Law.Law_Constant_swigregister(Law_Constant)
class Law_Linear(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Constructs an empty linear evolution law.

        """
        _Law.Law_Linear_swiginit(self, _Law.new_Law_Linear(*args))

    def Set(self, *args):
        r"""

        Parameters
        ----------
        Pdeb: float
        Valdeb: float
        Pfin: float
        Valfin: float

        Return
        -------
        None

        Description
        -----------
        Defines this linear evolution law by assigning both: - the bounds Pdeb and Pfin of the parameter, and - the values Valdeb and Valfin of the function at these two parametric bounds.

        """
        return _Law.Law_Linear_Set(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Linear_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Linear

# Register Law_Linear in _Law:
_Law.Law_Linear_swigregister(Law_Linear)
class Law_Interpol(Law_BSpFunc):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Constructs an empty interpolative evolution law. The function Set is used to define the law.

        """
        _Law.Law_Interpol_swiginit(self, _Law.new_Law_Interpol(*args))

    def Set(self, *args):
        r"""

        Parameters
        ----------
        ParAndRad: TColgp_Array1OfPnt2d
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Defines this evolution law by interpolating the set of 2D points ParAndRad. The Y coordinate of a point of ParAndRad is the value of the function at the parameter point given by its X coordinate. If Periodic is true, this function is assumed to be periodic. Warning - The X coordinates of points in the table ParAndRad must be given in ascendant order. - If Periodic is true, the first and last Y coordinates of points in the table ParAndRad are assumed to be equal. In addition, with the second syntax, Dd and Df are also assumed to be equal. If this is not the case, Set uses the first value(s) as last value(s).

        Parameters
        ----------
        ParAndRad: TColgp_Array1OfPnt2d
        Dd: float
        Df: float
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        Defines this evolution law by interpolating the set of 2D points ParAndRad. The Y coordinate of a point of ParAndRad is the value of the function at the parameter point given by its X coordinate. If Periodic is true, this function is assumed to be periodic. In the second syntax, Dd and Df define the values of the first derivative of the function at its first and last points. Warning - The X coordinates of points in the table ParAndRad must be given in ascendant order. - If Periodic is true, the first and last Y coordinates of points in the table ParAndRad are assumed to be equal. In addition, with the second syntax, Dd and Df are also assumed to be equal. If this is not the case, Set uses the first value(s) as last value(s).

        """
        return _Law.Law_Interpol_Set(self, *args)

    def SetInRelative(self, *args):
        r"""

        Parameters
        ----------
        ParAndRad: TColgp_Array1OfPnt2d
        Ud: float
        Uf: float
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        ParAndRad: TColgp_Array1OfPnt2d
        Ud: float
        Uf: float
        Dd: float
        Df: float
        Periodic: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _Law.Law_Interpol_SetInRelative(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Interpol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Interpol

# Register Law_Interpol in _Law:
_Law.Law_Interpol_swigregister(Law_Interpol)
class Law_S(Law_BSpFunc):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Constructs an empty 'S' evolution law.

        """
        _Law.Law_S_swiginit(self, _Law.new_Law_S(*args))

    def Set(self, *args):
        r"""

        Parameters
        ----------
        Pdeb: float
        Valdeb: float
        Pfin: float
        Valfin: float

        Return
        -------
        None

        Description
        -----------
        Defines this S evolution law by assigning both: - the bounds Pdeb and Pfin of the parameter, and - the values Valdeb and Valfin of the function at these two parametric bounds. The function is assumed to have the first derivatives equal to 0 at the two parameter points Pdeb and Pfin.

        Parameters
        ----------
        Pdeb: float
        Valdeb: float
        Ddeb: float
        Pfin: float
        Valfin: float
        Dfin: float

        Return
        -------
        None

        Description
        -----------
        Defines this S evolution law by assigning - the bounds Pdeb and Pfin of the parameter, - the values Valdeb and Valfin of the function at these two parametric bounds, and - the values Ddeb and Dfin of the first derivative of the function at these two parametric bounds.

        """
        return _Law.Law_S_Set(self, *args)


    @staticmethod
    def DownCast(t):
      return Handle_Law_S_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_S

# Register Law_S in _Law:
_Law.Law_S_swigregister(Law_S)



@deprecated
def law_MixBnd(*args):
	return law.MixBnd(*args)

@deprecated
def law_MixBnd(*args):
	return law.MixBnd(*args)

@deprecated
def law_MixTgt(*args):
	return law.MixTgt(*args)

@deprecated
def law_Reparametrize(*args):
	return law.Reparametrize(*args)

@deprecated
def law_Scale(*args):
	return law.Scale(*args)

@deprecated
def law_ScaleCub(*args):
	return law.ScaleCub(*args)

@deprecated
def Law_BSpline_MaxDegree(*args):
	return Law_BSpline.MaxDegree(*args)



