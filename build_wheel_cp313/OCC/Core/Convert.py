# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
Convert module, see official documentation at
https://dev.opencascade.org/doc/occt-7.9.0/refman/html/package_convert.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Convert
else:
    import _Convert

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Convert.delete_SwigPyIterator

    def value(self):
        return _Convert.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Convert.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Convert.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Convert.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Convert.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Convert.SwigPyIterator_copy(self)

    def next(self):
        return _Convert.SwigPyIterator_next(self)

    def __next__(self):
        return _Convert.SwigPyIterator___next__(self)

    def previous(self):
        return _Convert.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Convert.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Convert.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Convert.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Convert.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Convert.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Convert.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Convert.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Convert:
_Convert.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string

PYTHONOCC_DEBUG_EXCEPTIONS = _Convert.PYTHONOCC_DEBUG_EXCEPTIONS

def get_readable_class_name(class_name):
    return _Convert.get_readable_class_name(class_name)

def get_readable_method_name(method_name):
    return _Convert.get_readable_method_name(method_name)

def get_exception_type(error):
    return _Convert.get_exception_type(error)

def process_opencascade_exception(error, method_name, class_name):
    return _Convert.process_opencascade_exception(error, method_name, class_name)

import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _Convert.ios_base_erase_event
    imbue_event = _Convert.ios_base_imbue_event
    copyfmt_event = _Convert.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _Convert.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _Convert.ios_base_flags(self, *args)

    def setf(self, *args):
        return _Convert.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _Convert.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _Convert.ios_base_precision(self, *args)

    def width(self, *args):
        return _Convert.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _Convert.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _Convert.ios_base_imbue(self, __loc)

    def getloc(self):
        return _Convert.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _Convert.ios_base_xalloc()

    def iword(self, __ix):
        return _Convert.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _Convert.ios_base_pword(self, __ix)
    __swig_destroy__ = _Convert.delete_ios_base

# Register ios_base in _Convert:
_Convert.ios_base_swigregister(ios_base)
cvar = _Convert.cvar
ios_base.boolalpha = _Convert.cvar.ios_base_boolalpha
ios_base.dec = _Convert.cvar.ios_base_dec
ios_base.fixed = _Convert.cvar.ios_base_fixed
ios_base.hex = _Convert.cvar.ios_base_hex
ios_base.internal = _Convert.cvar.ios_base_internal
ios_base.left = _Convert.cvar.ios_base_left
ios_base.oct = _Convert.cvar.ios_base_oct
ios_base.right = _Convert.cvar.ios_base_right
ios_base.scientific = _Convert.cvar.ios_base_scientific
ios_base.showbase = _Convert.cvar.ios_base_showbase
ios_base.showpoint = _Convert.cvar.ios_base_showpoint
ios_base.showpos = _Convert.cvar.ios_base_showpos
ios_base.skipws = _Convert.cvar.ios_base_skipws
ios_base.unitbuf = _Convert.cvar.ios_base_unitbuf
ios_base.uppercase = _Convert.cvar.ios_base_uppercase
ios_base.adjustfield = _Convert.cvar.ios_base_adjustfield
ios_base.basefield = _Convert.cvar.ios_base_basefield
ios_base.floatfield = _Convert.cvar.ios_base_floatfield
ios_base.badbit = _Convert.cvar.ios_base_badbit
ios_base.eofbit = _Convert.cvar.ios_base_eofbit
ios_base.failbit = _Convert.cvar.ios_base_failbit
ios_base.goodbit = _Convert.cvar.ios_base_goodbit
ios_base.app = _Convert.cvar.ios_base_app
ios_base.ate = _Convert.cvar.ios_base_ate
ios_base.binary = _Convert.cvar.ios_base_binary
ios_base.ios_base_in = _Convert.cvar.ios_base_ios_base_in
ios_base.out = _Convert.cvar.ios_base_out
ios_base.trunc = _Convert.cvar.ios_base_trunc
ios_base.beg = _Convert.cvar.ios_base_beg
ios_base.cur = _Convert.cvar.ios_base_cur
ios_base.end = _Convert.cvar.ios_base_end

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _Convert.ios_rdstate(self)

    def clear(self, *args):
        return _Convert.ios_clear(self, *args)

    def setstate(self, __state):
        return _Convert.ios_setstate(self, __state)

    def good(self):
        return _Convert.ios_good(self)

    def eof(self):
        return _Convert.ios_eof(self)

    def fail(self):
        return _Convert.ios_fail(self)

    def bad(self):
        return _Convert.ios_bad(self)

    def exceptions(self, *args):
        return _Convert.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _Convert.ios_swiginit(self, _Convert.new_ios(__sb))
    __swig_destroy__ = _Convert.delete_ios

    def tie(self, *args):
        return _Convert.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _Convert.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _Convert.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _Convert.ios_fill(self, *args)

    def imbue(self, __loc):
        return _Convert.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _Convert.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _Convert.ios_widen(self, __c)

# Register ios in _Convert:
_Convert.ios_swigregister(ios)
class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Convert.ostream_swiginit(self, _Convert.new_ostream(__sb))
    __swig_destroy__ = _Convert.delete_ostream

    def __lshift__(self, *args):
        return _Convert.ostream___lshift__(self, *args)

    def put(self, __c):
        return _Convert.ostream_put(self, __c)

    def write(self, __s, __n):
        return _Convert.ostream_write(self, __s, __n)

    def flush(self):
        return _Convert.ostream_flush(self)

    def tellp(self):
        return _Convert.ostream_tellp(self)

    def seekp(self, *args):
        return _Convert.ostream_seekp(self, *args)

# Register ostream in _Convert:
_Convert.ostream_swigregister(ostream)
class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Convert.istream_swiginit(self, _Convert.new_istream(__sb))
    __swig_destroy__ = _Convert.delete_istream

    def __rshift__(self, *args):
        return _Convert.istream___rshift__(self, *args)

    def gcount(self):
        return _Convert.istream_gcount(self)

    def get(self, *args):
        return _Convert.istream_get(self, *args)

    def getline(self, *args):
        return _Convert.istream_getline(self, *args)

    def ignore(self, *args):
        return _Convert.istream_ignore(self, *args)

    def peek(self):
        return _Convert.istream_peek(self)

    def read(self, __s, __n):
        return _Convert.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _Convert.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _Convert.istream_putback(self, __c)

    def unget(self):
        return _Convert.istream_unget(self)

    def sync(self):
        return _Convert.istream_sync(self)

    def tellg(self):
        return _Convert.istream_tellg(self)

    def seekg(self, *args):
        return _Convert.istream_seekg(self, *args)

# Register istream in _Convert:
_Convert.istream_swigregister(istream)
class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _Convert.iostream_swiginit(self, _Convert.new_iostream(__sb))
    __swig_destroy__ = _Convert.delete_iostream

# Register iostream in _Convert:
_Convert.iostream_swigregister(iostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

endl_cb_ptr = _Convert.endl_cb_ptr
endl = _Convert.endl
ends_cb_ptr = _Convert.ends_cb_ptr
ends = _Convert.ends
flush_cb_ptr = _Convert.flush_cb_ptr
flush = _Convert.flush
import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

Convert_TgtThetaOver2 = _Convert.Convert_TgtThetaOver2
Convert_TgtThetaOver2_1 = _Convert.Convert_TgtThetaOver2_1
Convert_TgtThetaOver2_2 = _Convert.Convert_TgtThetaOver2_2
Convert_TgtThetaOver2_3 = _Convert.Convert_TgtThetaOver2_3
Convert_TgtThetaOver2_4 = _Convert.Convert_TgtThetaOver2_4
Convert_QuasiAngular = _Convert.Convert_QuasiAngular
Convert_RationalC1 = _Convert.Convert_RationalC1
Convert_Polynomial = _Convert.Convert_Polynomial


class Convert_ParameterisationType(IntEnum):
	Convert_TgtThetaOver2 = 0
	Convert_TgtThetaOver2_1 = 1
	Convert_TgtThetaOver2_2 = 2
	Convert_TgtThetaOver2_3 = 3
	Convert_TgtThetaOver2_4 = 4
	Convert_QuasiAngular = 5
	Convert_RationalC1 = 6
	Convert_Polynomial = 7
Convert_TgtThetaOver2 = Convert_ParameterisationType.Convert_TgtThetaOver2
Convert_TgtThetaOver2_1 = Convert_ParameterisationType.Convert_TgtThetaOver2_1
Convert_TgtThetaOver2_2 = Convert_ParameterisationType.Convert_TgtThetaOver2_2
Convert_TgtThetaOver2_3 = Convert_ParameterisationType.Convert_TgtThetaOver2_3
Convert_TgtThetaOver2_4 = Convert_ParameterisationType.Convert_TgtThetaOver2_4
Convert_QuasiAngular = Convert_ParameterisationType.Convert_QuasiAngular
Convert_RationalC1 = Convert_ParameterisationType.Convert_RationalC1
Convert_Polynomial = Convert_ParameterisationType.Convert_Polynomial

class Convert_SequenceOfArray1OfPoles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_begin(self)

    def end(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_end(self)

    def cbegin(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_cbegin(self)

    def cend(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_cend(self)

    def __init__(self, *args):
        _Convert.Convert_SequenceOfArray1OfPoles_swiginit(self, _Convert.new_Convert_SequenceOfArray1OfPoles(*args))

    def Size(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Size(self)

    def Length(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Length(self)

    def Lower(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Lower(self)

    def Upper(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Upper(self)

    def IsEmpty(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_IsEmpty(self)

    def Reverse(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Reverse(self)

    def Exchange(self, I, J):
        return _Convert.Convert_SequenceOfArray1OfPoles_Exchange(self, I, J)

    @staticmethod
    def delNode(theNode, theAl):
        return _Convert.Convert_SequenceOfArray1OfPoles_delNode(theNode, theAl)

    def Clear(self, theAllocator=0):
        return _Convert.Convert_SequenceOfArray1OfPoles_Clear(self, theAllocator)

    def Assign(self, theOther):
        return _Convert.Convert_SequenceOfArray1OfPoles_Assign(self, theOther)

    def Set(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_Set(self, *args)

    def Remove(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_Remove(self, *args)

    def Append(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_Append(self, *args)

    def Prepend(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_Prepend(self, *args)

    def InsertBefore(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles_InsertAfter(self, *args)

    def Split(self, theIndex, theSeq):
        return _Convert.Convert_SequenceOfArray1OfPoles_Split(self, theIndex, theSeq)

    def First(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_First(self)

    def ChangeFirst(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_ChangeFirst(self)

    def Last(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_Last(self)

    def ChangeLast(self):
        return _Convert.Convert_SequenceOfArray1OfPoles_ChangeLast(self)

    def Value(self, theIndex):
        return _Convert.Convert_SequenceOfArray1OfPoles_Value(self, theIndex)

    def ChangeValue(self, theIndex):
        return _Convert.Convert_SequenceOfArray1OfPoles_ChangeValue(self, theIndex)

    def __call__(self, *args):
        return _Convert.Convert_SequenceOfArray1OfPoles___call__(self, *args)

    def SetValue(self, theIndex, theItem):
        return _Convert.Convert_SequenceOfArray1OfPoles_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _Convert.delete_Convert_SequenceOfArray1OfPoles

    def __len__(self):
        return self.Size()


# Register Convert_SequenceOfArray1OfPoles in _Convert:
_Convert.Convert_SequenceOfArray1OfPoles_swigregister(Convert_SequenceOfArray1OfPoles)
class Convert_CompBezierCurves2dToBSplineCurve2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        AngularTolerance: float (optional, default to 1.0e-4)

        Return
        -------
        None

        Description
        -----------
        Constructs a framework for converting a sequence of adjacent non-rational Bezier curves into a BSpline curve. Knots will be created on the computed BSpline curve at each junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. AngularTolerance (given in radians, and defaulted to 1.0 e-4) will be used to check the parallelism of the two tangent vectors. Use the following functions: - AddCurve to define in sequence the adjacent Bezier curves to be converted, - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve.

        """
        _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_swiginit(self, _Convert.new_Convert_CompBezierCurves2dToBSplineCurve2d(*args))

    def AddCurve(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt2d

        Return
        -------
        None

        Description
        -----------
        Adds the Bezier curve defined by the table of poles Poles, to the sequence (still contained in this framework) of adjacent Bezier curves to be converted into a BSpline curve. Only polynomial (i.e. non-rational) Bezier curves are converted using this framework. If this is not the first call to the function (i.e. if this framework still contains data in its sequence of Bezier curves), the degree of continuity of the BSpline curve will be increased at the time of computation at the first point of the added Bezier curve (i.e. the first point of the Poles table). This will be the case if the tangent vector of the curve at this point is parallel to the tangent vector at the end point of the preceding Bezier curve in the sequence of Bezier curves still contained in this framework. An angular tolerance given at the time of construction of this framework, will be used to check the parallelism of the two tangent vectors. This checking procedure, and all the relative computations will be performed by the function Perform. When the sequence of adjacent Bezier curves is complete, use the following functions: - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve. Warning The sequence of Bezier curves treated by this framework is automatically initialized with the first Bezier curve when the function is first called. During subsequent use of this function, ensure that the first point of the added Bezier curve (i.e. the first point of the Poles table) is coincident with the last point of the sequence (i.e. the last point of the preceding Bezier curve in the sequence) of Bezier curves still contained in this framework. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above, as this condition is not checked either when defining the sequence of Bezier curves or at the time of computation.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_AddCurve(self, *args)

    def Degree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the degree of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Degree(self, *args)

    def KnotsAndMults(self, *args):
        r"""

        Parameters
        ----------
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger

        Return
        -------
        None

        Description
        -----------
        Loads the Knots table with the knots and the Mults table with the corresponding multiplicities of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Knots and Mults arrays must be equal to the number of knots in the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above as these conditions are not checked, and an error may occur.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults(self, *args)

    def NbKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbKnots(self, *args)

    def NbPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of poles of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbPoles(self, *args)

    def Perform(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Computes all the data needed to build a BSpline curve equivalent to the sequence of adjacent Bezier curves still contained in this framework. A knot is inserted on the computed BSpline curve at the junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. An angular tolerance given at the time of construction of this framework is used to check the parallelism of the two tangent vectors. Use the available consultation functions to access the computed data. This data may then be used to construct the BSpline curve. Warning Ensure that the curves in the sequence of Bezier curves contained in this framework are adjacent. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above as this condition is not checked, either when defining the Bezier curve sequence or at the time of computation.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Perform(self, *args)

    def Poles(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt2d

        Return
        -------
        None

        Description
        -----------
        Loads the Poles table with the poles of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Poles array must be equal to the number of poles of the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above, as these conditions are not checked, and an error may occur.

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Poles(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurves2dToBSplineCurve2d

# Register Convert_CompBezierCurves2dToBSplineCurve2d in _Convert:
_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_swigregister(Convert_CompBezierCurves2dToBSplineCurve2d)
class Convert_CompBezierCurvesToBSplineCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        AngularTolerance: float (optional, default to 1.0e-4)

        Return
        -------
        None

        Description
        -----------
        Constructs a framework for converting a sequence of adjacent non-rational Bezier curves into a BSpline curve. Knots will be created on the computed BSpline curve at each junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. AngularTolerance (given in radians, and defaulted to 1.0 e-4) will be used to check the parallelism of the two tangent vectors. Use the following functions: - AddCurve to define in sequence the adjacent Bezier curves to be converted, - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve.

        """
        _Convert.Convert_CompBezierCurvesToBSplineCurve_swiginit(self, _Convert.new_Convert_CompBezierCurvesToBSplineCurve(*args))

    def AddCurve(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt

        Return
        -------
        None

        Description
        -----------
        Adds the Bezier curve defined by the table of poles Poles, to the sequence (still contained in this framework) of adjacent Bezier curves to be converted into a BSpline curve. Only polynomial (i.e. non-rational) Bezier curves are converted using this framework. If this is not the first call to the function (i.e. if this framework still contains data in its Bezier curve sequence), the degree of continuity of the BSpline curve will be increased at the time of computation at the first point of the added Bezier curve (i.e. the first point of the Poles table). This will be the case if the tangent vector of the curve at this point is parallel to the tangent vector at the end point of the preceding Bezier curve in the Bezier curve sequence still contained in this framework. An angular tolerance given at the time of construction of this framework will be used to check the parallelism of the two tangent vectors. This checking procedure and all related computations will be performed by the Perform function. When the adjacent Bezier curve sequence is complete, use the following functions: - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve. Warning The Bezier curve sequence treated by this framework is automatically initialized with the first Bezier curve when the function is first called. During subsequent use of this function, ensure that the first point of the added Bezier curve (i.e. the first point of the Poles table) is coincident with the last point of the Bezier curve sequence (i.e. the last point of the preceding Bezier curve in the sequence) still contained in this framework. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above, as this condition is not checked either when defining the Bezier curve sequence or at the time of computation.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_AddCurve(self, *args)

    def Degree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the degree of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Degree(self, *args)

    def KnotsAndMults(self, *args):
        r"""

        Parameters
        ----------
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger

        Return
        -------
        None

        Description
        -----------
        - loads the Knots table with the knots, - and loads the Mults table with the corresponding multiplicities of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Knots and Mults arrays must be equal to the number of knots in the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above as these conditions are not checked, and an error may occur.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_KnotsAndMults(self, *args)

    def NbKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbKnots(self, *args)

    def NbPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of poles of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbPoles(self, *args)

    def Perform(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Computes all the data needed to build a BSpline curve equivalent to the adjacent Bezier curve sequence still contained in this framework. A knot is inserted on the computed BSpline curve at the junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. An angular tolerance given at the time of construction of this framework is used to check the parallelism of the two tangent vectors. Use the available consultation functions to access the computed data. This data may then be used to construct the BSpline curve. Warning Make sure that the curves in the Bezier curve sequence contained in this framework are adjacent. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above as this condition is not checked, either when defining the Bezier curve sequence or at the time of computation.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Perform(self, *args)

    def Poles(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt

        Return
        -------
        None

        Description
        -----------
        Loads the Poles table with the poles of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Poles array must be equal to the number of poles of the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above, as these conditions are not checked, and an error may occur.

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Poles(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurvesToBSplineCurve

# Register Convert_CompBezierCurvesToBSplineCurve in _Convert:
_Convert.Convert_CompBezierCurvesToBSplineCurve_swigregister(Convert_CompBezierCurvesToBSplineCurve)
class Convert_CompPolynomialToPoles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        NumCurves: int
        Continuity: int
        Dimension: int
        MaxDegree: int
        NumCoeffPerCurve: TColStd_HArray1OfInteger
        Coefficients: TColStd_HArray1OfReal
        PolynomialIntervals: TColStd_HArray2OfReal
        TrueIntervals: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        Warning! Continuity can be at MOST the maximum degree of the polynomial functions TrueIntervals: this is the true parameterisation for the composite curve that is: the curve has myContinuity if the nth curve is parameterized between myTrueIntervals(n) and myTrueIntervals(n+1) //! Coefficients have to be the implicit 'c form': Coefficients[Numcurves][MaxDegree+1][Dimension] //! Warning! The NumberOfCoefficient of an polynome is his degree + 1 Example: To convert the linear function f(x) = 2*x + 1 on the domaine [2,5] to BSpline with the bound [-1,1]. Arguments are: NumCurves = 1; Continuity = 1; Dimension = 1; MaxDegree = 1; NumCoeffPerCurve [1] = {2}; Coefficients[2] = {1, 2}; PolynomialIntervals[1,2] = {{2,5}} TrueIntervals[2] = {-1, 1}.

        Parameters
        ----------
        NumCurves: int
        Dimension: int
        MaxDegree: int
        Continuity: TColStd_Array1OfInteger
        NumCoeffPerCurve: TColStd_Array1OfInteger
        Coefficients: TColStd_Array1OfReal
        PolynomialIntervals: TColStd_Array2OfReal
        TrueIntervals: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        To Convert several span with different order of Continuity. Warning: The Length of Continuity have to be NumCurves-1.

        Parameters
        ----------
        Dimension: int
        MaxDegree: int
        Degree: int
        Coefficients: TColStd_Array1OfReal
        PolynomialIntervals: TColStd_Array1OfReal
        TrueIntervals: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        To Convert only one span.

        """
        _Convert.Convert_CompPolynomialToPoles_swiginit(self, _Convert.new_Convert_CompPolynomialToPoles(*args))

    def Degree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_CompPolynomialToPoles_Degree(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_CompPolynomialToPoles_IsDone(self, *args)

    def Knots(self, *args):
        r"""

        Parameters
        ----------
        K: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        Knots of the n-dimensional Bspline.

        """
        return _Convert.Convert_CompPolynomialToPoles_Knots(self, *args)

    def Multiplicities(self, *args):
        r"""

        Parameters
        ----------
        M: TColStd_HArray1OfInteger

        Return
        -------
        None

        Description
        -----------
        Multiplicities of the knots in the BSpline.

        """
        return _Convert.Convert_CompPolynomialToPoles_Multiplicities(self, *args)

    def NbKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Degree of the n-dimensional Bspline.

        """
        return _Convert.Convert_CompPolynomialToPoles_NbKnots(self, *args)

    def NbPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        number of poles of the n-dimensional BSpline.

        """
        return _Convert.Convert_CompPolynomialToPoles_NbPoles(self, *args)

    def Poles(self, *args):
        r"""

        Parameters
        ----------
        Poles: TColStd_HArray2OfReal

        Return
        -------
        None

        Description
        -----------
        returns the poles of the n-dimensional BSpline in the following format: [1..NumPoles][1..Dimension].

        """
        return _Convert.Convert_CompPolynomialToPoles_Poles(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompPolynomialToPoles

# Register Convert_CompPolynomialToPoles in _Convert:
_Convert.Convert_CompPolynomialToPoles_swigregister(Convert_CompPolynomialToPoles)
class Convert_ConicToBSplineCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BuildCosAndSin(self, *args):
        r"""

        Parameters
        ----------
        Parametrisation: Convert_ParameterisationType
        CosNumerator: TColStd_HArray1OfReal
        SinNumerator: TColStd_HArray1OfReal
        Denominator: TColStd_HArray1OfReal
        Knots: TColStd_HArray1OfReal
        Mults: TColStd_HArray1OfInteger

        Return
        -------
        Degree: int

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        Parametrisation: Convert_ParameterisationType
        UFirst: float
        ULast: float
        CosNumerator: TColStd_HArray1OfReal
        SinNumerator: TColStd_HArray1OfReal
        Denominator: TColStd_HArray1OfReal
        Knots: TColStd_HArray1OfReal
        Mults: TColStd_HArray1OfInteger

        Return
        -------
        Degree: int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_ConicToBSplineCurve_BuildCosAndSin(self, *args)

    def Degree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the degree of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_Degree(self, *args)

    def IsPeriodic(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the BSpline curve whose data is computed in this framework is periodic.

        """
        return _Convert.Convert_ConicToBSplineCurve_IsPeriodic(self, *args)

    def Knot(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the knot of index Index to the knots table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_Knot(self, *args)

    def Multiplicity(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        int

        Description
        -----------
        Returns the multiplicity of the knot of index Index to the knots table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_Multiplicity(self, *args)

    def NbKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_NbKnots(self, *args)

    def NbPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of poles of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_NbPoles(self, *args)

    def Pole(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        gp_Pnt2d

        Description
        -----------
        Returns the pole of index Index to the poles table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_Pole(self, *args)

    def Weight(self, *args):
        r"""

        Parameters
        ----------
        Index: int

        Return
        -------
        float

        Description
        -----------
        Returns the weight of the pole of index Index to the poles table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table of the BSpline curve whose data is computed in this framework.

        """
        return _Convert.Convert_ConicToBSplineCurve_Weight(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ConicToBSplineCurve

# Register Convert_ConicToBSplineCurve in _Convert:
_Convert.Convert_ConicToBSplineCurve_swigregister(Convert_ConicToBSplineCurve)
class Convert_ElementarySurfaceToBSplineSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsUPeriodic(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsUPeriodic(self, *args)

    def IsVPeriodic(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the BSpline surface whose data is computed in this framework is periodic in the u or v parametric direction.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsVPeriodic(self, *args)

    def NbUKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUKnots(self, *args)

    def NbUPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUPoles(self, *args)

    def NbVKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of knots for the u or v parametric direction of the BSpline surface whose data is computed in this framework .

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVKnots(self, *args)

    def NbVPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of poles for the u or v parametric direction of the BSpline surface whose data is computed in this framework.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVPoles(self, *args)

    def Pole(self, *args):
        r"""

        Parameters
        ----------
        UIndex: int
        VIndex: int

        Return
        -------
        gp_Pnt

        Description
        -----------
        Returns the pole of index (UIndex,VIndex) to the poles table of the BSpline surface whose data is computed in this framework. Exceptions Standard_OutOfRange if, for the BSpline surface whose data is computed in this framework: - UIndex is outside the bounds of the poles table in the u parametric direction, or - VIndex is outside the bounds of the poles table in the v parametric direction.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Pole(self, *args)

    def UDegree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UDegree(self, *args)

    def UKnot(self, *args):
        r"""

        Parameters
        ----------
        UIndex: int

        Return
        -------
        float

        Description
        -----------
        Returns the U-knot of range UIndex. Raised if UIndex < 1 or UIndex > NbUKnots.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UKnot(self, *args)

    def UMultiplicity(self, *args):
        r"""

        Parameters
        ----------
        UIndex: int

        Return
        -------
        int

        Description
        -----------
        Returns the multiplicity of the U-knot of range UIndex. Raised if UIndex < 1 or UIndex > NbUKnots.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UMultiplicity(self, *args)

    def VDegree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the degree for the u or v parametric direction of the BSpline surface whose data is computed in this framework.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VDegree(self, *args)

    def VKnot(self, *args):
        r"""

        Parameters
        ----------
        UIndex: int

        Return
        -------
        float

        Description
        -----------
        Returns the V-knot of range VIndex. Raised if VIndex < 1 or VIndex > NbVKnots.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VKnot(self, *args)

    def VMultiplicity(self, *args):
        r"""

        Parameters
        ----------
        VIndex: int

        Return
        -------
        int

        Description
        -----------
        Returns the multiplicity of the V-knot of range VIndex. Raised if VIndex < 1 or VIndex > NbVKnots.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VMultiplicity(self, *args)

    def Weight(self, *args):
        r"""

        Parameters
        ----------
        UIndex: int
        VIndex: int

        Return
        -------
        float

        Description
        -----------
        Returns the weight of the pole of index (UIndex,VIndex) to the poles table of the BSpline surface whose data is computed in this framework. Exceptions Standard_OutOfRange if, for the BSpline surface whose data is computed in this framework: - UIndex is outside the bounds of the poles table in the u parametric direction, or - VIndex is outside the bounds of the poles table in the v parametric direction.

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Weight(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ElementarySurfaceToBSplineSurface

# Register Convert_ElementarySurfaceToBSplineSurface in _Convert:
_Convert.Convert_ElementarySurfaceToBSplineSurface_swigregister(Convert_ElementarySurfaceToBSplineSurface)
class Convert_GridPolynomialToPoles(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        MaxUDegree: int
        MaxVDegree: int
        NumCoeff: TColStd_HArray1OfInteger
        Coefficients: TColStd_HArray1OfReal
        PolynomialUIntervals: TColStd_HArray1OfReal
        PolynomialVIntervals: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        To only one polynomial Surface. The Length of <PolynomialUIntervals> and <PolynomialVIntervals> have to be 2. This values defined the parametric domain of the Polynomial Equation. //! Coefficients: The <Coefficients> have to be formatted than an 'C array' [MaxUDegree+1] [MaxVDegree+1] [3].

        Parameters
        ----------
        NbUSurfaces: int
        NBVSurfaces: int
        UContinuity: int
        VContinuity: int
        MaxUDegree: int
        MaxVDegree: int
        NumCoeffPerSurface: TColStd_HArray2OfInteger
        Coefficients: TColStd_HArray1OfReal
        PolynomialUIntervals: TColStd_HArray1OfReal
        PolynomialVIntervals: TColStd_HArray1OfReal
        TrueUIntervals: TColStd_HArray1OfReal
        TrueVIntervals: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        To one grid of polynomial Surface. Warning! Continuity in each parametric direction can be at MOST the maximum degree of the polynomial functions. //! <TrueUIntervals>, <TrueVIntervals>: this is the true parameterisation for the composite surface //! Coefficients: The Coefficients have to be formatted than an 'C array' [NbVSurfaces] [NBUSurfaces] [MaxUDegree+1] [MaxVDegree+1] [3] raises DomainError if <NumCoeffPerSurface> is not a [1, NbVSurfaces*NbUSurfaces, 1,2] array. if <Coefficients> is not a.

        """
        _Convert.Convert_GridPolynomialToPoles_swiginit(self, _Convert.new_Convert_GridPolynomialToPoles(*args))

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_IsDone(self, *args)

    def NbUKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_NbUKnots(self, *args)

    def NbUPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_NbUPoles(self, *args)

    def NbVKnots(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_NbVKnots(self, *args)

    def NbVPoles(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_NbVPoles(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        UContinuity: int
        VContinuity: int
        MaxUDegree: int
        MaxVDegree: int
        NumCoeffPerSurface: TColStd_HArray2OfInteger
        Coefficients: TColStd_HArray1OfReal
        PolynomialUIntervals: TColStd_HArray1OfReal
        PolynomialVIntervals: TColStd_HArray1OfReal
        TrueUIntervals: TColStd_HArray1OfReal
        TrueVIntervals: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_Perform(self, *args)

    def Poles(self, *args):
        r"""
        Return
        -------
        opencascade::handle<TColgp_HArray2OfPnt>

        Description
        -----------
        returns the poles of the BSpline Surface.

        """
        return _Convert.Convert_GridPolynomialToPoles_Poles(self, *args)

    def UDegree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_UDegree(self, *args)

    def UKnots(self, *args):
        r"""
        Return
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        Description
        -----------
        Knots in the U direction.

        """
        return _Convert.Convert_GridPolynomialToPoles_UKnots(self, *args)

    def UMultiplicities(self, *args):
        r"""
        Return
        -------
        opencascade::handle<TColStd_HArray1OfInteger>

        Description
        -----------
        Multiplicities of the knots in the U direction.

        """
        return _Convert.Convert_GridPolynomialToPoles_UMultiplicities(self, *args)

    def VDegree(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        No available documentation.

        """
        return _Convert.Convert_GridPolynomialToPoles_VDegree(self, *args)

    def VKnots(self, *args):
        r"""
        Return
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        Description
        -----------
        Knots in the V direction.

        """
        return _Convert.Convert_GridPolynomialToPoles_VKnots(self, *args)

    def VMultiplicities(self, *args):
        r"""
        Return
        -------
        opencascade::handle<TColStd_HArray1OfInteger>

        Description
        -----------
        Multiplicities of the knots in the V direction.

        """
        return _Convert.Convert_GridPolynomialToPoles_VMultiplicities(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_GridPolynomialToPoles

# Register Convert_GridPolynomialToPoles in _Convert:
_Convert.Convert_GridPolynomialToPoles_swigregister(Convert_GridPolynomialToPoles)
class Convert_CircleToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        C: gp_Circ2d
        Parameterisation: Convert_ParameterisationType (optional, default to Convert_TgtThetaOver2)

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline curve has the same orientation as the circle C.

        Parameters
        ----------
        C: gp_Circ2d
        U1: float
        U2: float
        Parameterisation: Convert_ParameterisationType (optional, default to Convert_TgtThetaOver2)

        Return
        -------
        None

        Description
        -----------
        The circle C is limited between the parametric values U1, U2 in radians. U1 and U2 [0.0, 2*Pi] . The equivalent B-spline curve is oriented from U1 to U2 and has the same orientation as the circle C. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi.

        """
        _Convert.Convert_CircleToBSplineCurve_swiginit(self, _Convert.new_Convert_CircleToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CircleToBSplineCurve

# Register Convert_CircleToBSplineCurve in _Convert:
_Convert.Convert_CircleToBSplineCurve_swigregister(Convert_CircleToBSplineCurve)
class Convert_ConeToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        C: gp_Cone
        U1: float
        U2: float
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the Cone in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.

        Parameters
        ----------
        C: gp_Cone
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the Cone in the U and V parametric directions. //! Raised if V1 = V2.

        """
        _Convert.Convert_ConeToBSplineSurface_swiginit(self, _Convert.new_Convert_ConeToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ConeToBSplineSurface

# Register Convert_ConeToBSplineSurface in _Convert:
_Convert.Convert_ConeToBSplineSurface_swigregister(Convert_ConeToBSplineSurface)
class Convert_CylinderToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Cyl: gp_Cylinder
        U1: float
        U2: float
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-splineSurface as the same orientation as the cylinder in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.

        Parameters
        ----------
        Cyl: gp_Cylinder
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-splineSurface as the same orientation as the cylinder in the U and V parametric directions. //! Raised if V1 = V2.

        """
        _Convert.Convert_CylinderToBSplineSurface_swiginit(self, _Convert.new_Convert_CylinderToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CylinderToBSplineSurface

# Register Convert_CylinderToBSplineSurface in _Convert:
_Convert.Convert_CylinderToBSplineSurface_swigregister(Convert_CylinderToBSplineSurface)
class Convert_EllipseToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        E: gp_Elips2d
        Parameterisation: Convert_ParameterisationType (optional, default to Convert_TgtThetaOver2)

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline curve has the same orientation as the ellipse E.

        Parameters
        ----------
        E: gp_Elips2d
        U1: float
        U2: float
        Parameterisation: Convert_ParameterisationType (optional, default to Convert_TgtThetaOver2)

        Return
        -------
        None

        Description
        -----------
        The ellipse E is limited between the parametric values U1, U2. The equivalent B-spline curve is oriented from U1 to U2 and has the same orientation as E. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi.

        """
        _Convert.Convert_EllipseToBSplineCurve_swiginit(self, _Convert.new_Convert_EllipseToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_EllipseToBSplineCurve

# Register Convert_EllipseToBSplineCurve in _Convert:
_Convert.Convert_EllipseToBSplineCurve_swigregister(Convert_EllipseToBSplineCurve)
class Convert_HyperbolaToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        H: gp_Hypr2d
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        The hyperbola H is limited between the parametric values U1, U2 and the equivalent B-spline curve has the same orientation as the hyperbola.

        """
        _Convert.Convert_HyperbolaToBSplineCurve_swiginit(self, _Convert.new_Convert_HyperbolaToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_HyperbolaToBSplineCurve

# Register Convert_HyperbolaToBSplineCurve in _Convert:
_Convert.Convert_HyperbolaToBSplineCurve_swigregister(Convert_HyperbolaToBSplineCurve)
class Convert_ParabolaToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Prb: gp_Parab2d
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        The parabola Prb is limited between the parametric values U1, U2 and the equivalent B-spline curve as the same orientation as the parabola Prb.

        """
        _Convert.Convert_ParabolaToBSplineCurve_swiginit(self, _Convert.new_Convert_ParabolaToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ParabolaToBSplineCurve

# Register Convert_ParabolaToBSplineCurve in _Convert:
_Convert.Convert_ParabolaToBSplineCurve_swigregister(Convert_ParabolaToBSplineCurve)
class Convert_SphereToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Sph: gp_Sphere
        U1: float
        U2: float
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.

        Parameters
        ----------
        Sph: gp_Sphere
        Param1: float
        Param2: float
        UTrim: bool (optional, default to Standard_True)

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions. //! Raised if UTrim = True and Param1 = Param2 or Param1 = Param2 + 2.0 * Pi Raised if UTrim = False and Param1 = Param2.

        Parameters
        ----------
        Sph: gp_Sphere

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions.

        """
        _Convert.Convert_SphereToBSplineSurface_swiginit(self, _Convert.new_Convert_SphereToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_SphereToBSplineSurface

# Register Convert_SphereToBSplineSurface in _Convert:
_Convert.Convert_SphereToBSplineSurface_swigregister(Convert_SphereToBSplineSurface)
class Convert_TorusToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        T: gp_Torus
        U1: float
        U2: float
        V1: float
        V2: float

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2 or V1 = V2 + 2.0 * Pi.

        Parameters
        ----------
        T: gp_Torus
        Param1: float
        Param2: float
        UTrim: bool (optional, default to Standard_True)

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions. //! Raised if Param1 = Param2 or Param1 = Param2 + 2.0 * Pi.

        Parameters
        ----------
        T: gp_Torus

        Return
        -------
        None

        Description
        -----------
        The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions.

        """
        _Convert.Convert_TorusToBSplineSurface_swiginit(self, _Convert.new_Convert_TorusToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_TorusToBSplineSurface

# Register Convert_TorusToBSplineSurface in _Convert:
_Convert.Convert_TorusToBSplineSurface_swigregister(Convert_TorusToBSplineSurface)

Convert_SequenceOfArray1OfPoles2d=OCC.Core.TColgp.TColgp_SequenceOfArray1OfPnt2d


